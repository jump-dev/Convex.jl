<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Supported operations · Convex.jl</title><meta name="title" content="Supported operations · Convex.jl"/><meta property="og:title" content="Supported operations · Convex.jl"/><meta property="twitter:title" content="Supported operations · Convex.jl"/><meta name="description" content="Documentation for Convex.jl."/><meta property="og:description" content="Documentation for Convex.jl."/><meta property="twitter:description" content="Documentation for Convex.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Convex.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../introduction/installation/">Installation</a></li><li><a class="tocitem" href="../../introduction/quick_tutorial/">Quick Tutorial</a></li><li><a class="tocitem" href="../../introduction/dcp/">Extended formulations and the DCP ruleset</a></li><li><a class="tocitem" href="../../introduction/faq/">FAQ</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">General examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/general_examples/DCP_analysis/">DCP analysis</a></li><li><a class="tocitem" href="../../examples/general_examples/basic_usage/">Basic Usage</a></li><li><a class="tocitem" href="../../examples/general_examples/chebyshev_center/">Chebyshev center</a></li><li><a class="tocitem" href="../../examples/general_examples/control/">Control</a></li><li><a class="tocitem" href="../../examples/general_examples/dualization/">Dualization</a></li><li><a class="tocitem" href="../../examples/general_examples/huber_regression/">Huber regression</a></li><li><a class="tocitem" href="../../examples/general_examples/lasso_regression/">Lasso, Ridge and Elastic Net Regressions</a></li><li><a class="tocitem" href="../../examples/general_examples/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../examples/general_examples/max_entropy/">Entropy Maximization</a></li><li><a class="tocitem" href="../../examples/general_examples/optimal_advertising/">Optimal advertising</a></li><li><a class="tocitem" href="../../examples/general_examples/robust_approx_fitting/">Robust approximate fitting</a></li><li><a class="tocitem" href="../../examples/general_examples/svm/">Support vector machine</a></li><li><a class="tocitem" href="../../examples/general_examples/svm_l1regularization/">SVM with L^1 regularization</a></li><li><a class="tocitem" href="../../examples/general_examples/trade_off_curves/">Regularized least-squares</a></li><li><a class="tocitem" href="../../examples/general_examples/worst_case_analysis/">Worst case risk analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Mixed integer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/mixed_integer/binary_knapsack/">Binary (or 0-1) knapsack problem</a></li><li><a class="tocitem" href="../../examples/mixed_integer/n_queens/">N queens</a></li><li><a class="tocitem" href="../../examples/mixed_integer/section_allocation/">Section Allocation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Optimization with complex variables</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/optimization_with_complex_variables/Fidelity in Quantum Information Theory/">Fidelity in quantum information theory</a></li><li><a class="tocitem" href="../../examples/optimization_with_complex_variables/phase_recovery_using_MaxCut/">Phase recovery using MaxCut</a></li><li><a class="tocitem" href="../../examples/optimization_with_complex_variables/povm_simulation/">POVM simulation</a></li><li><a class="tocitem" href="../../examples/optimization_with_complex_variables/power_flow_optimization/">Power flow optimization</a></li><li><a class="tocitem" href="../../examples/optimization_with_complex_variables/quantum_conditional_entropy/">Continuity of the quantum conditional entropy</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Portfolio optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/portfolio_optimization/portfolio_optimization/">Portfolio Optimization</a></li><li><a class="tocitem" href="../../examples/portfolio_optimization/portfolio_optimization2/">Portfolio Optimization - Markowitz Efficient Frontier</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Supplemental material</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/supplemental_material/Convex.jl_intro_ISMP2015/">Convex Optimization in Julia</a></li><li><a class="tocitem" href="../../examples/supplemental_material/paper_examples/">Paper examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Time series</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/time_series/time_series/">Time Series Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Tomography</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/tomography/tomography/">Tomography</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/types/">Basic Types</a></li><li><a class="tocitem" href="../../manual/operations/">Supported Operations</a></li><li><a class="tocitem" href="../../manual/complex-domain_optimization/">Complex-domain Optimization</a></li><li><a class="tocitem" href="../../manual/solvers/">Solvers</a></li><li><a class="tocitem" href="../../manual/performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../../manual/advanced/">Advanced Features</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developer/problem_depot/">Problem Depot</a></li><li><a class="tocitem" href="../../developer/contributing/">Contributing</a></li><li><a class="tocitem" href="../../developer/credits/">Credits</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href>Supported operations</a><ul class="internal"><li><a class="tocitem" href="#*"><span><code>*</code></span></a></li><li><a class="tocitem" href="#"><span><code>+</code></span></a></li><li><a class="tocitem" href="#-2"><span><code>-</code></span></a></li><li><a class="tocitem" href="#/"><span><code>/</code></span></a></li><li><a class="tocitem" href="#.*"><span><code>.*</code></span></a></li><li><a class="tocitem" href="#./"><span><code>./</code></span></a></li><li><a class="tocitem" href="#."><span><code>.^</code></span></a></li><li><a class="tocitem" href="#abs"><span><code>abs</code></span></a></li><li><a class="tocitem" href="#abs2"><span><code>abs2</code></span></a></li><li><a class="tocitem" href="#adjoint"><span><code>adjoint</code></span></a></li><li><a class="tocitem" href="#conj"><span><code>conj</code></span></a></li><li><a class="tocitem" href="#conv"><span><code>conv</code></span></a></li><li><a class="tocitem" href="#diag"><span><code>diag</code></span></a></li><li><a class="tocitem" href="#diagm"><span><code>diagm</code></span></a></li><li><a class="tocitem" href="#dot"><span><code>dot</code></span></a></li><li><a class="tocitem" href="#dotsort"><span><code>dotsort</code></span></a></li><li><a class="tocitem" href="#eigmax"><span><code>eigmax</code></span></a></li><li><a class="tocitem" href="#eigmin"><span><code>eigmin</code></span></a></li><li><a class="tocitem" href="#entropy"><span><code>entropy</code></span></a></li><li><a class="tocitem" href="#entropy_elementwise"><span><code>entropy_elementwise</code></span></a></li><li><a class="tocitem" href="#exp"><span><code>exp</code></span></a></li><li><a class="tocitem" href="#geomean"><span><code>geomean</code></span></a></li><li><a class="tocitem" href="#hcat"><span><code>hcat</code></span></a></li><li><a class="tocitem" href="#hinge_loss"><span><code>hinge_loss</code></span></a></li><li><a class="tocitem" href="#huber"><span><code>huber</code></span></a></li><li><a class="tocitem" href="#hvcat"><span><code>hvcat</code></span></a></li><li><a class="tocitem" href="#imag"><span><code>imag</code></span></a></li><li><a class="tocitem" href="#inner_product"><span><code>inner_product</code></span></a></li><li><a class="tocitem" href="#invpos"><span><code>invpos</code></span></a></li><li><a class="tocitem" href="#kron"><span><code>kron</code></span></a></li><li><a class="tocitem" href="#lieb_ando"><span><code>lieb_ando</code></span></a></li><li><a class="tocitem" href="#log"><span><code>log</code></span></a></li><li><a class="tocitem" href="#log_perspective"><span><code>log_perspective</code></span></a></li><li><a class="tocitem" href="#logdet"><span><code>logdet</code></span></a></li><li><a class="tocitem" href="#logisticloss"><span><code>logisticloss</code></span></a></li><li><a class="tocitem" href="#logsumexp"><span><code>logsumexp</code></span></a></li><li><a class="tocitem" href="#matrixfrac"><span><code>matrixfrac</code></span></a></li><li><a class="tocitem" href="#max"><span><code>max</code></span></a></li><li><a class="tocitem" href="#maximum"><span><code>maximum</code></span></a></li><li><a class="tocitem" href="#min"><span><code>min</code></span></a></li><li><a class="tocitem" href="#minimum"><span><code>minimum</code></span></a></li><li><a class="tocitem" href="#neg"><span><code>neg</code></span></a></li><li><a class="tocitem" href="#norm"><span><code>norm</code></span></a></li><li><a class="tocitem" href="#norm2"><span><code>norm2</code></span></a></li><li><a class="tocitem" href="#nuclearnorm"><span><code>nuclearnorm</code></span></a></li><li><a class="tocitem" href="#opnorm"><span><code>opnorm</code></span></a></li><li><a class="tocitem" href="#partialtrace"><span><code>partialtrace</code></span></a></li><li><a class="tocitem" href="#partialtranspose"><span><code>partialtranspose</code></span></a></li><li><a class="tocitem" href="#pos"><span><code>pos</code></span></a></li><li><a class="tocitem" href="#qol_elementwise"><span><code>qol_elementwise</code></span></a></li><li><a class="tocitem" href="#quadform"><span><code>quadform</code></span></a></li><li><a class="tocitem" href="#quadoverlin"><span><code>quadoverlin</code></span></a></li><li><a class="tocitem" href="#quantum_entropy"><span><code>quantum_entropy</code></span></a></li><li><a class="tocitem" href="#quantum_relative_entropy"><span><code>quantum_relative_entropy</code></span></a></li><li><a class="tocitem" href="#rationalnorm"><span><code>rationalnorm</code></span></a></li><li><a class="tocitem" href="#real"><span><code>real</code></span></a></li><li><a class="tocitem" href="#relative_entropy"><span><code>relative_entropy</code></span></a></li><li><a class="tocitem" href="#reshape"><span><code>reshape</code></span></a></li><li><a class="tocitem" href="#rootdet"><span><code>rootdet</code></span></a></li><li><a class="tocitem" href="#sigmamax"><span><code>sigmamax</code></span></a></li><li><a class="tocitem" href="#sqrt"><span><code>sqrt</code></span></a></li><li><a class="tocitem" href="#square"><span><code>square</code></span></a></li><li><a class="tocitem" href="#sum"><span><code>sum</code></span></a></li><li><a class="tocitem" href="#sumlargest"><span><code>sumlargest</code></span></a></li><li><a class="tocitem" href="#sumlargesteigs"><span><code>sumlargesteigs</code></span></a></li><li><a class="tocitem" href="#sumsmallest"><span><code>sumsmallest</code></span></a></li><li><a class="tocitem" href="#sumsquares"><span><code>sumsquares</code></span></a></li><li><a class="tocitem" href="#tr"><span><code>tr</code></span></a></li><li><a class="tocitem" href="#trace_logm"><span><code>trace_logm</code></span></a></li><li><a class="tocitem" href="#trace_mpower"><span><code>trace_mpower</code></span></a></li><li><a class="tocitem" href="#transpose"><span><code>transpose</code></span></a></li><li><a class="tocitem" href="#vcat"><span><code>vcat</code></span></a></li><li><a class="tocitem" href="#vec"><span><code>vec</code></span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Supported operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Supported operations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/Convex.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/Convex.jl/blob/master/docs/src/reference/atoms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Supported-operations"><a class="docs-heading-anchor" href="#Supported-operations">Supported operations</a><a id="Supported-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-operations" title="Permalink"></a></h1><p>Convex.jl supports the following functions. These functions may be composed according to the <a href="http://dcp.stanford.edu">DCP</a> composition rules to form new convex, concave, or affine expressions.</p><h2 id="*"><a class="docs-heading-anchor" href="#*"><code>*</code></a><a id="*-1"></a><a class="docs-heading-anchor-permalink" href="#*" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Base.:*-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(x::Convex.AbstractExpr, y::Convex.AbstractExpr)</code></pre><p>The binary multiplication operator <span>$x \times y$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">ulia&gt; x = Variable();

julia&gt; 2 * x
* (affine; real)
├─ [2;;]
└─ real variable (id: 709…007)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; y = [1, 2, 3];

julia&gt; x&#39; * y
* (affine; real)
├─ reshape (affine; real)
│  └─ * (affine; real)
│     ├─ 3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries
│     └─ reshape (affine; real)
│        └─ …
└─ [1; 2; 3;;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L122-L152">source</a></section></article><h2 id><a class="docs-heading-anchor" href="#"><code>+</code></a><a id="-1"></a><a class="docs-heading-anchor-permalink" href="#" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Base.:+-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:+(x::Convex.AbstractExpr, y::Convex.AbstractExpr)
Base.:+(x::Convex.Value, y::Convex.AbstractExpr)
Base.:+(x::Convex.AbstractExpr, y::Convex.Value)</code></pre><p>The addition operator <span>$x + y$</span>.</p><p><strong>Examples</strong></p><p>Applies to scalar expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; x + 1
+ (affine; real)
├─ real variable (id: 110…477)
└─ [1;;]</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; y = [1, 2, 3];

julia&gt; atom = x + y
+ (affine; real)
├─ 3-element real variable (id: 458…482)
└─ [1; 2; 3;;]

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L6-L41">source</a></section></article><h2 id="-2"><a class="docs-heading-anchor" href="#-2"><code>-</code></a><a class="docs-heading-anchor-permalink" href="#-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:--Tuple{Convex.AbstractExpr}" href="#Base.:--Tuple{Convex.AbstractExpr}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:-(x::Convex.AbstractExpr)</code></pre><p>The univariate negation operator <span>$-x$</span>.</p><p><strong>Examples</strong></p><p>Applies to scalar expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; -x
Convex.NegateAtom (affine; real)
├─ real variable (id: 161…677)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = -x
Convex.NegateAtom (affine; real)
└─ 3-element real variable (id: 137…541)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L88-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:--Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Base.:--Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:-(x::Convex.AbstractExpr, y::Convex.AbstractExpr)
Base.:-(x::Convex.Value, y::Convex.AbstractExpr)
Base.:-(x::Convex.AbstractExpr, y::Convex.Value)</code></pre><p>The subtraction operator <span>$x - y$</span>.</p><p><strong>Examples</strong></p><p>Applies to scalar expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; x - 1
+ (affine; real)
├─ real variable (id: 161…677)
└─ [-1;;]</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; y = [1, 2, 3];

julia&gt; atom = y - x
+ (affine; real)
├─ [1; 2; 3;;]
└─ Convex.NegateAtom (affine; real)
   └─ 3-element real variable (id: 242…661)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L48-L81">source</a></section></article><h2 id="/"><a class="docs-heading-anchor" href="#/"><code>/</code></a><a id="/-1"></a><a class="docs-heading-anchor-permalink" href="#/" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:/-Tuple{Convex.AbstractExpr, Union{Number, AbstractArray}}" href="#Base.:/-Tuple{Convex.AbstractExpr, Union{Number, AbstractArray}}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:/(x::Convex.AbstractExpr, y::Convex.Value)</code></pre><p>The binary division operator <span>$\frac{x}{y}$</span>.</p><p><strong>Examples</strong></p><p>Applies to a scalar expression:</p><pre><code class="language-julia-repl hljs">ulia&gt; x = Variable();

julia&gt; x / 2</code></pre><p>and element-wise to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = x / 2
* (affine; real)
├─ 3-element real variable (id: 129…611)
└─ [0.5;;]

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L164-L189">source</a></section></article><h2 id=".*"><a class="docs-heading-anchor" href="#.*"><code>.*</code></a><a id=".*-1"></a><a class="docs-heading-anchor-permalink" href="#.*" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.broadcasted-Tuple{typeof(*), Convex.AbstractExpr, Convex.AbstractExpr}" href="#Base.Broadcast.broadcasted-Tuple{typeof(*), Convex.AbstractExpr, Convex.AbstractExpr}"><code>Base.Broadcast.broadcasted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x::Convex.AbstractExpr .* y::Convex.AbstractExpr</code></pre><p>Element-wise multiplication between matrices <code>x</code> and <code>y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2);

julia&gt; atom = x .* 2
* (affine; real)
├─ 2-element real variable (id: 197…044)
└─ [2;;]

julia&gt; atom = x .* [2, 4]
.* (affine; real)
├─ 2-element real variable (id: 197…044)
└─ [2; 4;;]

julia&gt; size(atom)
(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L199-L222">source</a></section></article><h2 id="./"><a class="docs-heading-anchor" href="#./"><code>./</code></a><a id="./-1"></a><a class="docs-heading-anchor-permalink" href="#./" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.broadcasted-Tuple{typeof(/), Convex.AbstractExpr, Union{Number, AbstractArray}}" href="#Base.Broadcast.broadcasted-Tuple{typeof(/), Convex.AbstractExpr, Union{Number, AbstractArray}}"><code>Base.Broadcast.broadcasted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x::Convex.AbstractExpr ./ y::Convex.AbstractExpr</code></pre><p>Element-wise division between matrices <code>x</code> and <code>y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2);

julia&gt; atom = x ./ 2
* (affine; real)
├─ 2-element real variable (id: 875…859)
└─ [0.5;;]

julia&gt; atom = x ./ [2, 4]
.* (affine; real)
├─ 2-element real variable (id: 875…859)
└─ [0.5; 0.25;;]

julia&gt; size(atom)
(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L244-L267">source</a></section></article><h2 id="."><a class="docs-heading-anchor" href="#."><code>.^</code></a><a id=".-1"></a><a class="docs-heading-anchor-permalink" href="#." title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.broadcasted-Tuple{typeof(^), Convex.AbstractExpr, Int64}" href="#Base.Broadcast.broadcasted-Tuple{typeof(^), Convex.AbstractExpr, Int64}"><code>Base.Broadcast.broadcasted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x::Convex.AbstractExpr .^ k::Int</code></pre><p>Element-wise exponentiation of <code>x</code> to the power of <code>k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2);

julia&gt; atom = x .^ 2
qol_elem (convex; positive)
├─ 2-element real variable (id: 131…737)
└─ [1.0; 1.0;;]

julia&gt; size(atom)
(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L276-L294">source</a></section></article><h2 id="abs"><a class="docs-heading-anchor" href="#abs"><code>abs</code></a><a id="abs-1"></a><a class="docs-heading-anchor-permalink" href="#abs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.abs-Tuple{Convex.AbstractExpr}" href="#Base.abs-Tuple{Convex.AbstractExpr}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.abs(x::Convex.AbstractExpr)</code></pre><p>The epigraph of <span>$|x|$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; abs(x)
abs (convex; positive)
└─ real variable (id: 103…720)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = abs(x)
abs (convex; positive)
└─ 3-element real variable (id: 389…882)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L311-L340">source</a></section></article><h2 id="abs2"><a class="docs-heading-anchor" href="#abs2"><code>abs2</code></a><a id="abs2-1"></a><a class="docs-heading-anchor-permalink" href="#abs2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.abs2-Tuple{Convex.AbstractExpr}" href="#Base.abs2-Tuple{Convex.AbstractExpr}"><code>Base.abs2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.abs2(x::Convex.AbstractExpr)</code></pre><p>The epigraph of <span>$|x|^2$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; abs2(x)
qol_elem (convex; positive)
├─ abs (convex; positive)
│  └─ real variable (id: 319…413)
└─ [1.0;;]</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = abs2(x)
qol_elem (convex; positive)
├─ abs (convex; positive)
│  └─ 3-element real variable (id: 123…996)
└─ [1.0; 1.0; 1.0;;]

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L343-L376">source</a></section></article><h2 id="adjoint"><a class="docs-heading-anchor" href="#adjoint"><code>adjoint</code></a><a id="adjoint-1"></a><a class="docs-heading-anchor-permalink" href="#adjoint" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint-Tuple{Convex.AbstractExpr}" href="#Base.adjoint-Tuple{Convex.AbstractExpr}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.adjoint(x::AbstractExpr)</code></pre><p>The transpose of the conjugated matrix <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = ComplexVariable(2, 2);

julia&gt; atom = adjoint(x)
reshape (affine; complex)
└─ * (affine; complex)
   ├─ 4×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 4 stored entries
   └─ reshape (affine; complex)
      └─ conj (affine; complex)
         └─ …

julia&gt; size(atom)
(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L379-L400">source</a></section></article><h2 id="conj"><a class="docs-heading-anchor" href="#conj"><code>conj</code></a><a id="conj-1"></a><a class="docs-heading-anchor-permalink" href="#conj" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj-Tuple{Convex.AbstractExpr}" href="#Base.conj-Tuple{Convex.AbstractExpr}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.conj(x::Convex.AbstractExpr)</code></pre><p>The complex conjugate of <code>x</code>.</p><p>If <code>x</code> is real, this function returns <code>x</code>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = ComplexVariable();

julia&gt; conj(x)
conj (affine; complex)
└─ complex variable (id: 180…137)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">conj (affine; complex)
└─ complex variable (id: 180…137)

julia&gt; x = ComplexVariable(3);

julia&gt; atom = conj(x)
conj (affine; complex)
└─ 3-element complex variable (id: 104…031)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L407-L441">source</a></section></article><h2 id="conv"><a class="docs-heading-anchor" href="#conv"><code>conv</code></a><a id="conv-1"></a><a class="docs-heading-anchor-permalink" href="#conv" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.conv-Tuple{Union{Number, AbstractArray}, Convex.AbstractExpr}" href="#Convex.conv-Tuple{Union{Number, AbstractArray}, Convex.AbstractExpr}"><code>Convex.conv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Convex.conv(x::Convex.AbstractExpr, y::Convex.AbstractExpr)</code></pre><p>The convolution between two vectors <code>x</code> and <code>y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2);

julia&gt; y = [2, 4];

julia&gt; atom = conv(x, y)
* (affine; real)
├─ 3×2 SparseArrays.SparseMatrixCSC{Int64, Int64} with 4 stored entries
└─ 2-element real variable (id: 663…363)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/reformulations/conv.jl#L29-L49">source</a></section></article><h2 id="diag"><a class="docs-heading-anchor" href="#diag"><code>diag</code></a><a id="diag-1"></a><a class="docs-heading-anchor-permalink" href="#diag" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.diag" href="#LinearAlgebra.diag"><code>LinearAlgebra.diag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.diag(x::Convex.AbstractExpr, k::Int = 0)</code></pre><p>Return the <code>k</code>-th diagonnal of the matrix <code>X</code> as a column vector.</p><p><strong>Examples</strong></p><p>Applies to a single square matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = diag(x, 0)
diag (affine; real)
└─ 2×2 real variable (id: 724…318)

julia&gt; size(atom)
(2, 1)

julia&gt; atom = diag(x, 1)
diag (affine; real)
└─ 2×2 real variable (id: 147…856)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L453-L479">source</a></section></article><h2 id="diagm"><a class="docs-heading-anchor" href="#diagm"><code>diagm</code></a><a id="diagm-1"></a><a class="docs-heading-anchor-permalink" href="#diagm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.diagm-Tuple{Convex.AbstractExpr}" href="#LinearAlgebra.diagm-Tuple{Convex.AbstractExpr}"><code>LinearAlgebra.diagm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.diagm(x::Convex.AbstractExpr)</code></pre><p>Create a diagonal matrix out of the vector <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2);

julia&gt; atom = diagm(x)
diagm (affine; real)
└─ 2-element real variable (id: 541…968)

julia&gt; size(atom)
(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L482-L499">source</a></section></article><h2 id="dot"><a class="docs-heading-anchor" href="#dot"><code>dot</code></a><a id="dot-1"></a><a class="docs-heading-anchor-permalink" href="#dot" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#LinearAlgebra.dot-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.dot(x::Convex.AbstractExpr, y::Convex.AbstractExpr)</code></pre><p>The dot product <span>$x \cdot y$</span>. If <code>x</code> is complex, it is conjugated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = ComplexVariable(2);

julia&gt; y = [1, 2];

julia&gt; atom = dot(x, y)
sum (affine; complex)
└─ .* (affine; complex)
   ├─ conj (affine; complex)
   │  └─ 2-element complex variable (id: 133…443)
   └─ [1; 2;;]

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/reformulations/dot.jl#L19-L41">source</a></section></article><h2 id="dotsort"><a class="docs-heading-anchor" href="#dotsort"><code>dotsort</code></a><a id="dotsort-1"></a><a class="docs-heading-anchor-permalink" href="#dotsort" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.dotsort-Tuple{Convex.AbstractExpr, Union{Number, AbstractArray}}" href="#Convex.dotsort-Tuple{Convex.AbstractExpr, Union{Number, AbstractArray}}"><code>Convex.dotsort</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dotsort(x::Convex.AbstractExpr, y::Convex.Value)
dotsort(x::Convex.Value, y::Convex.AbstractExpr)</code></pre><p>Computes <code>dot(sort(x), sort(y))</code>, where <code>x</code> or <code>y</code> is constant.</p><p>For example, if <code>x = Variable(6)</code> and <code>y = [1 1 1 0 0 0]</code>, this atom computes the sum of the three largest elements of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(4);

julia&gt; atom = dotsort(x, [1, 0, 0, 1])
dotsort (convex; real)
└─ 4-element real variable (id: 128…367)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L512-L533">source</a></section></article><h2 id="eigmax"><a class="docs-heading-anchor" href="#eigmax"><code>eigmax</code></a><a id="eigmax-1"></a><a class="docs-heading-anchor-permalink" href="#eigmax" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigmax-Tuple{Convex.AbstractExpr}" href="#LinearAlgebra.eigmax-Tuple{Convex.AbstractExpr}"><code>LinearAlgebra.eigmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.eigmax(X::Convex.AbstractExpr)</code></pre><p>The epigraph of the maximum eigen value of <span>$X$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single square matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = eigmax(x)
eigmin (convex; real)
└─ 2×2 real variable (id: 428…695)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L537-L556">source</a></section></article><h2 id="eigmin"><a class="docs-heading-anchor" href="#eigmin"><code>eigmin</code></a><a id="eigmin-1"></a><a class="docs-heading-anchor-permalink" href="#eigmin" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigmin-Tuple{Convex.AbstractExpr}" href="#LinearAlgebra.eigmin-Tuple{Convex.AbstractExpr}"><code>LinearAlgebra.eigmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.eigmin(X::Convex.AbstractExpr)</code></pre><p>The hypograph of the minimum eigen value of <span>$X$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single square matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = eigmin(x)
eigmin (concave; real)
└─ 2×2 real variable (id: 428…695)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L559-L578">source</a></section></article><h2 id="entropy"><a class="docs-heading-anchor" href="#entropy"><code>entropy</code></a><a id="entropy-1"></a><a class="docs-heading-anchor-permalink" href="#entropy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.entropy-Tuple{Convex.AbstractExpr}" href="#Convex.entropy-Tuple{Convex.AbstractExpr}"><code>Convex.entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">entropy(x::Convex.AbstractExpr)</code></pre><p>The hypograph of <span>$\sum_i -x_i \log x_i$</span>.</p><p><strong>Examples</strong></p><p>Applies to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = entropy(x)
sum (concave; real)
└─ entropy (concave; real)
   └─ 3-element real variable (id: 901…778)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L581-L601">source</a></section></article><h2 id="entropy_elementwise"><a class="docs-heading-anchor" href="#entropy_elementwise"><code>entropy_elementwise</code></a><a id="entropy_elementwise-1"></a><a class="docs-heading-anchor-permalink" href="#entropy_elementwise" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.entropy_elementwise-Tuple{Convex.AbstractExpr}" href="#Convex.entropy_elementwise-Tuple{Convex.AbstractExpr}"><code>Convex.entropy_elementwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">entropy_elementwise(x::Convex.AbstractExpr)</code></pre><p>The hypograph of <span>$-x \log x$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; entropy_elementwise(x)
entropy (concave; real)
└─ real variable (id: 172…395)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = entropy_elementwise(x)
entropy (concave; real)
└─ 3-element real variable (id: 140…126)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L604-L633">source</a></section></article><h2 id="exp"><a class="docs-heading-anchor" href="#exp"><code>exp</code></a><a id="exp-1"></a><a class="docs-heading-anchor-permalink" href="#exp" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Tuple{Convex.AbstractExpr}" href="#Base.exp-Tuple{Convex.AbstractExpr}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.exp(x::Convex.AbstractExpr)</code></pre><p>The epigraph of <span>$e^x$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; exp(x)
exp (convex; positive)
└─ real variable (id: 103…720)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = exp(x)
exp (convex; positive)
└─ 3-element real variable (id: 389…882)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L636-L665">source</a></section></article><h2 id="geomean"><a class="docs-heading-anchor" href="#geomean"><code>geomean</code></a><a id="geomean-1"></a><a class="docs-heading-anchor-permalink" href="#geomean" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.geomean-Tuple{Vararg{Union{Convex.AbstractExpr, Number, AbstractArray}}}" href="#Convex.geomean-Tuple{Vararg{Union{Convex.AbstractExpr, Number, AbstractArray}}}"><code>Convex.geomean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geomean(x::Convex.AbstractExpr...)</code></pre><p>The hypograph of the geometric mean <span>$\sqrt[n]{x_1 \cdot x_2 \cdot \ldots x_n}$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; y = Variable();

julia&gt; geomean(x, y)
geomean (concave; positive)
├─ real variable (id: 163…519)
└─ real variable (id: 107…393)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; y = Variable(3);

julia&gt; atom = geomean(x, y)
geomean (concave; positive)
├─ 3-element real variable (id: 177…782)
└─ 3-element real variable (id: 307…913)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L668-L703">source</a></section></article><h2 id="hcat"><a class="docs-heading-anchor" href="#hcat"><code>hcat</code></a><a id="hcat-1"></a><a class="docs-heading-anchor-permalink" href="#hcat" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hcat-Tuple{Vararg{Convex.AbstractExpr}}" href="#Base.hcat-Tuple{Vararg{Convex.AbstractExpr}}"><code>Base.hcat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.hcat(args::AbstractExpr...)</code></pre><p>Horizontally concatenate <code>args</code>.</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = hcat(x, x)
hcat (affine; real)
├─ 2×2 real variable (id: 111…376)
└─ 2×2 real variable (id: 111…376)

julia&gt; size(atom)
(2, 4)</code></pre><p>You can also use the Julia <code>[x x]</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = [x x]
hcat (affine; real)
├─ 2×2 real variable (id: 111…376)
└─ 2×2 real variable (id: 111…376)

julia&gt; size(atom)
(2, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L706-L740">source</a></section></article><h2 id="hinge_loss"><a class="docs-heading-anchor" href="#hinge_loss"><code>hinge_loss</code></a><a id="hinge_loss-1"></a><a class="docs-heading-anchor-permalink" href="#hinge_loss" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.hinge_loss-Tuple{Convex.AbstractExpr}" href="#Convex.hinge_loss-Tuple{Convex.AbstractExpr}"><code>Convex.hinge_loss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hinge_loss(x::Convex.AbstractExpr)</code></pre><p>The epigraph of <span>$\max(1 - x, 0)$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; hinge_loss(x)
max (convex; positive)
├─ + (affine; real)
│  ├─ [1;;]
│  └─ Convex.NegateAtom (affine; real)
│     └─ real variable (id: 129…000)
└─ [0;;]</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = hinge_loss(x)
max (convex; positive)
├─ + (affine; real)
│  ├─ * (constant; positive)
│  │  ├─ [1;;]
│  │  └─ [1.0; 1.0; 1.0;;]
│  └─ Convex.NegateAtom (affine; real)
│     └─ 3-element real variable (id: 125…591)
└─ [0;;]

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L802-L841">source</a></section></article><h2 id="huber"><a class="docs-heading-anchor" href="#huber"><code>huber</code></a><a id="huber-1"></a><a class="docs-heading-anchor-permalink" href="#huber" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.huber" href="#Convex.huber"><code>Convex.huber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">huber(x::Convex.AbstractExpr, M::Real = 1.0)</code></pre><p>The epigraph of the Huber loss function:</p><p class="math-container">\[\begin{cases}
    x^2         &amp; |x| \le M \\
    2M|x| - M^2 &amp; |x| &gt; M
\end{cases}\]</p><p>where <span>$M \ge 1$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; huber(x, 2.5)
huber (convex; positive)
└─ real variable (id: 973…369)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = huber(x)
huber (convex; positive)
└─ 3-element real variable (id: 896…728)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L844-L880">source</a></section></article><h2 id="hvcat"><a class="docs-heading-anchor" href="#hvcat"><code>hvcat</code></a><a id="hvcat-1"></a><a class="docs-heading-anchor-permalink" href="#hvcat" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hvcat-Tuple{Tuple{Vararg{Int64}}, Vararg{Union{Convex.AbstractExpr, Number, AbstractArray}}}" href="#Base.hvcat-Tuple{Tuple{Vararg{Int64}}, Vararg{Union{Convex.AbstractExpr, Number, AbstractArray}}}"><code>Base.hvcat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.hvcat(
    rows::Tuple{Vararg{Int}},
    args::Union{AbstractExpr,Value}...,
)</code></pre><p>Horizontally and vertically concatenate <code>args</code> in single call.</p><p><code>rows</code> is the number of arguments to vertically concatenate into each column.</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><p>To make the matrix:</p><pre><code class="nohighlight hljs">a    b[1] b[2]
c[1] c[2] c[3]</code></pre><p>do:</p><pre><code class="language-julia-repl hljs">julia&gt; a = Variable();

julia&gt; b = Variable(1, 2);

julia&gt; c = Variable(1, 3);

julia&gt; atom = [a b; c]  # Syntactic sugar for: hvcat((2, 1), a, b, c)
vcat (affine; real)
├─ hcat (affine; real)
│  ├─ real variable (id: 429…021)
│  └─ 1×2 real variable (id: 120…326)
└─ hcat (affine; real)
   └─ 1×3 real variable (id: 124…615)

julia&gt; size(atom)
(2, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L750-L788">source</a></section></article><h2 id="imag"><a class="docs-heading-anchor" href="#imag"><code>imag</code></a><a id="imag-1"></a><a class="docs-heading-anchor-permalink" href="#imag" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.imag-Tuple{Convex.AbstractExpr}" href="#Base.imag-Tuple{Convex.AbstractExpr}"><code>Base.imag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.imag(x::Convex.AbstractExpr)</code></pre><p>Return the imaginary component of <code>x</code>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = ComplexVariable();

julia&gt; imag(x)
imag (affine; real)
└─ complex variable (id: 407…692)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = ComplexVariable(3);

julia&gt; atom = imag(x)
imag (affine; real)
└─ 3-element complex variable (id: 435…057)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L883-L912">source</a></section></article><h2 id="inner_product"><a class="docs-heading-anchor" href="#inner_product"><code>inner_product</code></a><a id="inner_product-1"></a><a class="docs-heading-anchor-permalink" href="#inner_product" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.inner_product-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Convex.inner_product-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Convex.inner_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner_product(x::AbstractExpr, y::AbstractExpr)</code></pre><p>The inner product <span>$tr(x^\top y)$</span> where <code>x</code> and <code>y</code> are square matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; y = [1 3; 2 4];

julia&gt; atom = inner_product(x, y)
real (affine; real)
└─ sum (affine; real)
   └─ diag (affine; real)
      └─ * (affine; real)
         ├─ …
         └─ …

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L919-L942">source</a></section></article><h2 id="invpos"><a class="docs-heading-anchor" href="#invpos"><code>invpos</code></a><a id="invpos-1"></a><a class="docs-heading-anchor-permalink" href="#invpos" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.invpos-Tuple{Convex.AbstractExpr}" href="#Convex.invpos-Tuple{Convex.AbstractExpr}"><code>Convex.invpos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invpos(x::Convex.AbstractExpr)</code></pre><p>The epigraph of <span>$\frac{1}{x}$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; invpos(x)
qol_elem (convex; positive)
├─ [1.0;;]
└─ real variable (id: 139…839)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = invpos(x)
qol_elem (convex; positive)
├─ [1.0; 1.0; 1.0;;]
└─ 3-element real variable (id: 133…285)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L954-L985">source</a></section></article><h2 id="kron"><a class="docs-heading-anchor" href="#kron"><code>kron</code></a><a id="kron-1"></a><a class="docs-heading-anchor-permalink" href="#kron" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.kron-Tuple{Union{Number, AbstractArray}, Convex.AbstractExpr}" href="#Base.kron-Tuple{Union{Number, AbstractArray}, Convex.AbstractExpr}"><code>Base.kron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.kron(x::Convex.AbstractExpr, y::Convex.AbstractExpr)</code></pre><p>The Kronecker (outer) product.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2);

julia&gt; y = [1 2];

julia&gt; atom = kron(x, y)
vcat (affine; real)
├─ * (affine; real)
│  ├─ index (affine; real)
│  │  └─ 2-element real variable (id: 369…232)
│  └─ [1 2]
└─ * (affine; real)
   ├─ index (affine; real)
   │  └─ 2-element real variable (id: 369…232)
   └─ [1 2]

julia&gt; size(atom)
(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/reformulations/kron.jl#L6-L32">source</a></section></article><h2 id="lieb_ando"><a class="docs-heading-anchor" href="#lieb_ando"><code>lieb_ando</code></a><a id="lieb_ando-1"></a><a class="docs-heading-anchor-permalink" href="#lieb_ando" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.lieb_ando-Tuple{Convex.AbstractExpr, Convex.AbstractExpr, Union{Convex.Constant, AbstractMatrix}, Rational}" href="#Convex.lieb_ando-Tuple{Convex.AbstractExpr, Convex.AbstractExpr, Union{Convex.Constant, AbstractMatrix}, Rational}"><code>Convex.lieb_ando</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lieb_ando(
    A::Union{AbstractMatrix,Constant},
    B::Union{AbstractMatrix,Constant},
    K::Union{AbstractMatrix,Constant},
    t::Rational,
)</code></pre><p>Returns <code>LinearAlgebra.tr(K&#39; * A^{1-t} * K * B^t)</code> where <code>A</code> and <code>B</code> are positive semidefinite matrices and <code>K</code> is an arbitrary matrix (possibly rectangular).</p><p><code>lieb_ando(A, B, K, t)</code> is concave in <code>(A, B)</code> for <code>t</code> in <code>[0, 1]</code>, and convex in <code>(A, B)</code> for <code>t</code> in <code>[-1, 0)</code> or <code>(1, 2]</code>. <code>K</code> is a fixed matrix.</p><p>Seems numerically unstable when t is on the endpoints of these ranges.</p><p><strong>Reference</strong></p><p>Ported from CVXQUAD which is based on the paper: &quot;Lieb&#39;s concavity theorem, matrix geometric means and semidefinite optimization&quot; by Hamza Fawzi and James Saunderson (arXiv:1512.03401)</p><p><strong>Examples</strong></p><p>Note that <code>lieb_ando</code> is implemented as a subproblem, so the returned atom is a <code>Convex.Problem</code> object. The <code>Problem</code> atom can still be used as a regular <code>1x1</code> atom in other expressions.</p><pre><code class="language-julia-repl hljs">julia&gt; A = Semidefinite(2, 2);

julia&gt; B = Semidefinite(3, 3);

julia&gt; K = [1 2 3; 4 5 6];

julia&gt; atom = lieb_ando(A, B, K, 1 // 2)
Problem statistics
  problem is DCP         : true
  number of variables    : 3 (49 scalar elements)
  number of constraints  : 4 (157 scalar elements)
  number of coefficients : 76
  number of atoms        : 26

Solution summary
  termination status : OPTIMIZE_NOT_CALLED
  primal status      : NO_SOLUTION
  dual status        : NO_SOLUTION

Expression graph
  maximize
   └─ real (affine; real)
      └─ sum (affine; real)
         └─ diag (affine; real)
            └─ …
  subject to
   ├─ GeometricMeanHypoConeSquare constraint (convex)
   │  └─ vcat (affine; real)
   │     ├─ reshape (affine; real)
   │     │  └─ …
   │     ├─ reshape (affine; real)
   │     │  └─ …
   │     └─ reshape (affine; real)
   │        └─ …
   ├─ PSD constraint (convex)
   │  └─ 6×6 real variable (id: 173…902)
   ├─ PSD constraint (convex)
   │  └─ 6×6 real variable (id: 173…902)
   ⋮


julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/reformulations/lieb_ando.jl#L7-L81">source</a></section></article><h2 id="log"><a class="docs-heading-anchor" href="#log"><code>log</code></a><a id="log-1"></a><a class="docs-heading-anchor-permalink" href="#log" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.log-Tuple{Convex.AbstractExpr}" href="#Base.log-Tuple{Convex.AbstractExpr}"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.log(x::Convex.AbstractExpr)</code></pre><p>The hypograph of <span>$\log(x)$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; log(x)
log (concave; real)
└─ real variable (id: 103…720)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = log(x)
log (concave; real)
└─ 3-element real variable (id: 161…499)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L988-L1017">source</a></section></article><h2 id="log_perspective"><a class="docs-heading-anchor" href="#log_perspective"><code>log_perspective</code></a><a id="log_perspective-1"></a><a class="docs-heading-anchor-permalink" href="#log_perspective" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.log_perspective-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Convex.log_perspective-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Convex.log_perspective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_perspective(x::Convex.AbstractExpr, y::Convex.AbstractExpr)</code></pre><p>The hypograph the perspective of of the log function: <span>$\sum y_i*\log \frac{x_i}{y_i}$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; y = Variable();

julia&gt; log_perspective(x, y)
Convex.NegateAtom (concave; real)
└─ relative_entropy (convex; real)
   ├─ real variable (id: 136…971)
   └─ real variable (id: 131…344)</code></pre><p>And to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; y = Variable(3);

julia&gt; atom = log_perspective(x, y)
Convex.NegateAtom (concave; real)
└─ relative_entropy (convex; real)
   ├─ 3-element real variable (id: 854…248)
   └─ 3-element real variable (id: 111…174)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1020-L1058">source</a></section></article><h2 id="logdet"><a class="docs-heading-anchor" href="#logdet"><code>logdet</code></a><a id="logdet-1"></a><a class="docs-heading-anchor-permalink" href="#logdet" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.logdet-Tuple{Convex.AbstractExpr}" href="#LinearAlgebra.logdet-Tuple{Convex.AbstractExpr}"><code>LinearAlgebra.logdet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.logdet(X::Convex.AbstractExpr)</code></pre><p>The hypograph of <span>$\log(\det(X))$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single matrix expression:</p><pre><code class="language-julia-repl hljs">julia&gt; X = Variable(2, 2);

julia&gt; atom = logdet(X)
logdet (concave; real)
└─ 2×2 real variable (id: 159…883)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1066-L1085">source</a></section></article><h2 id="logisticloss"><a class="docs-heading-anchor" href="#logisticloss"><code>logisticloss</code></a><a id="logisticloss-1"></a><a class="docs-heading-anchor-permalink" href="#logisticloss" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.logisticloss-Tuple{Convex.AbstractExpr}" href="#Convex.logisticloss-Tuple{Convex.AbstractExpr}"><code>Convex.logisticloss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logisticloss(x::Convex.AbstractExpr)</code></pre><p>Reformulation for epigraph of the logistic loss: <span>$\sum_i \log(e^x_i + 1)$</span>.</p><p>This reformulation uses <a href="#logsumexp"><code>logsumexp</code></a>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; logisticloss(x)
logsumexp (convex; real)
└─ vcat (affine; real)
   ├─ real variable (id: 444…892)
   └─ [0;;]</code></pre><p>And to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = logisticloss(x)
+ (convex; real)
├─ logsumexp (convex; real)
│  └─ vcat (affine; real)
│     ├─ index (affine; real)
│     │  └─ …
│     └─ [0;;]
├─ logsumexp (convex; real)
│  └─ vcat (affine; real)
│     ├─ index (affine; real)
│     │  └─ …
│     └─ [0;;]
└─ logsumexp (convex; real)
   └─ vcat (affine; real)
      ├─ index (affine; real)
      │  └─ …
      └─ [0;;]

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1088-L1135">source</a></section></article><h2 id="logsumexp"><a class="docs-heading-anchor" href="#logsumexp"><code>logsumexp</code></a><a id="logsumexp-1"></a><a class="docs-heading-anchor-permalink" href="#logsumexp" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.logsumexp-Tuple{Convex.AbstractExpr}" href="#Convex.logsumexp-Tuple{Convex.AbstractExpr}"><code>Convex.logsumexp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logsumexp(x::Convex.AbstractExpr)</code></pre><p>The epigraph of <span>$\log\left(\sum_i e^{x_i}\right)$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 3);

julia&gt; atom = logsumexp(x)
logsumexp (convex; real)
└─ 2×3 real variable (id: 121…604)

julia&gt; size(atom)
(1, 1)

julia&gt; atom = logsumexp(x; dims = 1)
logsumexp (convex; real)
└─ 2×3 real variable (id: 121…604)

julia&gt; size(atom)
(1, 3)

julia&gt; atom = logsumexp(x; dims = 2)
logsumexp (convex; real)
└─ 2×3 real variable (id: 121…604)

julia&gt; size(atom)
(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1143-L1176">source</a></section></article><h2 id="matrixfrac"><a class="docs-heading-anchor" href="#matrixfrac"><code>matrixfrac</code></a><a id="matrixfrac-1"></a><a class="docs-heading-anchor-permalink" href="#matrixfrac" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.matrixfrac-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Convex.matrixfrac-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Convex.matrixfrac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrixfrac(x::AbstractExpr, P::AbstractExpr)</code></pre><p>The epigraph of <span>$x^\top P^{-1} x$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2);

julia&gt; P = Variable(2, 2);

julia&gt; atom = matrixfrac(x, P)
matrixfrac (convex; positive)
├─ 2-element real variable (id: 139…388)
└─ 2×2 real variable (id: 126…414)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1179-L1199">source</a></section></article><h2 id="max"><a class="docs-heading-anchor" href="#max"><code>max</code></a><a id="max-1"></a><a class="docs-heading-anchor-permalink" href="#max" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.max-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Base.max-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Base.max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.max(x::Convex.AbstractExpr, y::Convex.AbstractExpr)
Base.max(x::Convex.AbstractExpr, y::Convex.Value)
Base.max(x::Convex.Value, y::Convex.AbstractExpr)</code></pre><p>The hypograph of <span>$max(x, y)$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; max(x, 1)
max (convex; real)
├─ real variable (id: 183…974)
└─ [1;;]</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; y = [1, 2, 3];

julia&gt; atom = max(x, y)
max (convex; real)
├─ 3-element real variable (id: 153…965)
└─ [1; 2; 3;;]

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1206-L1241">source</a></section></article><h2 id="maximum"><a class="docs-heading-anchor" href="#maximum"><code>maximum</code></a><a id="maximum-1"></a><a class="docs-heading-anchor-permalink" href="#maximum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum-Tuple{Convex.AbstractExpr}" href="#Base.maximum-Tuple{Convex.AbstractExpr}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.maximum(x::Convex.AbstractExpr)</code></pre><p>The hypograph of <span>$max(x...)$</span>.</p><p><strong>Examples</strong></p><p>Applies to a matrix expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = maximum(x)
maximum (convex; real)
└─ 3-element real variable (id: 159…219)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1248-L1267">source</a></section></article><h2 id="min"><a class="docs-heading-anchor" href="#min"><code>min</code></a><a id="min-1"></a><a class="docs-heading-anchor-permalink" href="#min" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.min-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Base.min-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Base.min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.min(x::Convex.AbstractExpr, y::Convex.AbstractExpr)
Base.min(x::Convex.Value, y::Convex.AbstractExpr)
Base.min(x::Convex.AbstractExpr, y::Convex.Value)</code></pre><p>The epigraph of <span>$min(x, y)$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; min(x, 1)
min (concave; real)
├─ real variable (id: 183…974)
└─ [1;;]</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; y = [1, 2, 3];

julia&gt; atom = min(x, y)
min (concave; real)
├─ 3-element real variable (id: 153…965)
└─ [1; 2; 3;;]

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1270-L1305">source</a></section></article><h2 id="minimum"><a class="docs-heading-anchor" href="#minimum"><code>minimum</code></a><a id="minimum-1"></a><a class="docs-heading-anchor-permalink" href="#minimum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum-Tuple{Convex.AbstractExpr}" href="#Base.minimum-Tuple{Convex.AbstractExpr}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.minimum(x::Convex.AbstractExpr)</code></pre><p>The epigraph of <span>$min(x...)$</span>.</p><p><strong>Examples</strong></p><p>Applies to a matrix expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = minimum(x)
minimum (convex; real)
└─ 3-element real variable (id: 159…219)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1312-L1331">source</a></section></article><h2 id="neg"><a class="docs-heading-anchor" href="#neg"><code>neg</code></a><a id="neg-1"></a><a class="docs-heading-anchor-permalink" href="#neg" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.neg-Tuple{Convex.AbstractExpr}" href="#Convex.neg-Tuple{Convex.AbstractExpr}"><code>Convex.neg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neg(x::Convex.AbstractExpr)</code></pre><p>The epigraph of <span>$\max(-x, 0)$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; neg(x)
max (convex; positive)
├─ Convex.NegateAtom (affine; real)
│  └─ real variable (id: 467…111)
└─ [0;;]</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = neg(x)
max (convex; positive)
├─ Convex.NegateAtom (affine; real)
│  └─ 3-element real variable (id: 224…439)
└─ [0;;]

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1334-L1367">source</a></section></article><h2 id="norm"><a class="docs-heading-anchor" href="#norm"><code>norm</code></a><a id="norm-1"></a><a class="docs-heading-anchor-permalink" href="#norm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">norm(x::AbstractExpr, p::Real = 2)</code></pre><p>Computes the <code>p</code>-norm <code>‖x‖ₚ = (∑ᵢ |xᵢ|^p)^(1/p)</code> of a vector expression <code>x</code>.</p><p>Matrices are vectorized (i.e., <code>norm(x)</code> is the same as <code>norm(vec(x))</code>.)</p><p>The return value depends on the value of <code>p</code>. Specialized cases are used for <code>p = 1</code>, <code>p = 2</code>, and <code>p = Inf</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2);

julia&gt; atom = norm(x, 1)
sum (convex; positive)
└─ abs (convex; positive)
   └─ 2-element real variable (id: 779…899)

julia&gt; size(atom)
(1, 1)

julia&gt; norm(x, 2)
norm2 (convex; positive)
└─ 2-element real variable (id: 779…899)

julia&gt; norm(x, Inf)
maximum (convex; positive)
└─ abs (convex; positive)
   └─ 2-element real variable (id: 779…899)

julia&gt; norm(x, 3 // 2)
rationalnorm (convex; positive)
└─ 2-element real variable (id: 779…899)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/reformulations/norm.jl#L6-L42">source</a></section></article><h2 id="norm2"><a class="docs-heading-anchor" href="#norm2"><code>norm2</code></a><a id="norm2-1"></a><a class="docs-heading-anchor-permalink" href="#norm2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm2-Tuple{Convex.AbstractExpr}" href="#LinearAlgebra.norm2-Tuple{Convex.AbstractExpr}"><code>LinearAlgebra.norm2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.norm2(x::Convex.AbstractExpr)</code></pre><p>The epigraph of the 2-norm <span>$||x||_2$</span>.</p><p><strong>Examples</strong></p><p>Applies to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = norm2(x)
norm2 (convex; positive)
└─ 3-element real variable (id: 162…975)

julia&gt; size(atom)
(3, 1)</code></pre><p>And to a complex:</p><pre><code class="language-julia-repl hljs">julia&gt; y = ComplexVariable(3);

julia&gt; atom = norm2(y)
norm2 (convex; positive)
└─ vcat (affine; real)
   ├─ real (affine; real)
   │  └─ 3-element complex variable (id: 120…942)
   └─ imag (affine; real)
      └─ 3-element complex variable (id: 120…942)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1370-L1406">source</a></section></article><h2 id="nuclearnorm"><a class="docs-heading-anchor" href="#nuclearnorm"><code>nuclearnorm</code></a><a id="nuclearnorm-1"></a><a class="docs-heading-anchor-permalink" href="#nuclearnorm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.nuclearnorm-Tuple{Convex.AbstractExpr}" href="#Convex.nuclearnorm-Tuple{Convex.AbstractExpr}"><code>Convex.nuclearnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nuclearnorm(x::Convex.AbstractExpr)</code></pre><p>The epigraph of the nuclear norm <span>$||X||_*$</span>, which is the sum of the singular values of <span>$X$</span>.</p><p><strong>Examples</strong></p><p>Applies to a real-valued matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = nuclearnorm(x)
nuclearnorm (convex; positive)
└─ 2×2 real variable (id: 106…758)

julia&gt; size(atom)
(1, 1)

julia&gt; y = ComplexVariable(2, 2);

julia&gt; atom = nuclearnorm(y)
nuclearnorm (convex; positive)
└─ 2×2 complex variable (id: 577…313)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1414-L1443">source</a></section></article><h2 id="opnorm"><a class="docs-heading-anchor" href="#opnorm"><code>opnorm</code></a><a id="opnorm-1"></a><a class="docs-heading-anchor-permalink" href="#opnorm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.opnorm" href="#LinearAlgebra.opnorm"><code>LinearAlgebra.opnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.opnorm(x::Convex.AbstractExpr, p::Real = 2)</code></pre><p>The epigraph of the matrix norm <span>$||X||_p$</span>.</p><p><strong>Examples</strong></p><p>Applies to a real- or complex-valued matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = LinearAlgebra.opnorm(x, 1)
maximum (convex; positive)
└─ * (convex; positive)
   ├─ [1.0 1.0]
   └─ abs (convex; positive)
      └─ 2×2 real variable (id: 106…758)

julia&gt; atom = LinearAlgebra.opnorm(x, 2)
opnorm (convex; positive)
└─ 2×2 real variable (id: 106…758)

julia&gt; atom = LinearAlgebra.opnorm(x, Inf)
maximum (convex; positive)
└─ * (convex; positive)
    ├─ abs (convex; positive)
    │  └─ 2×2 real variable (id: 106…758)
    └─ [1.0; 1.0;;]


julia&gt; y = ComplexVariable(2, 2);

julia&gt; atom = maximum (convex; positive)
└─ * (convex; positive)
   ├─ abs (convex; positive)
   │  └─ 2×2 complex variable (id: 116…943)
   └─ [1.0; 1.0;;]

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1446-L1488">source</a></section></article><h2 id="partialtrace"><a class="docs-heading-anchor" href="#partialtrace"><code>partialtrace</code></a><a id="partialtrace-1"></a><a class="docs-heading-anchor-permalink" href="#partialtrace" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.partialtrace-Tuple{Any, Int64, Vector}" href="#Convex.partialtrace-Tuple{Any, Int64, Vector}"><code>Convex.partialtrace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partialtrace(x, sys::Int, dims::Vector)</code></pre><p>Returns the partial trace of <code>x</code> over the <code>sys</code>th system, where <code>dims</code> is a vector of integers encoding the dimensions of each subsystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/reformulations/partialtrace.jl#L29-L34">source</a></section></article><h2 id="partialtranspose"><a class="docs-heading-anchor" href="#partialtranspose"><code>partialtranspose</code></a><a id="partialtranspose-1"></a><a class="docs-heading-anchor-permalink" href="#partialtranspose" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.partialtranspose-Tuple{Union{Convex.AbstractExpr, AbstractMatrix}, Int64, Vector}" href="#Convex.partialtranspose-Tuple{Union{Convex.AbstractExpr, AbstractMatrix}, Int64, Vector}"><code>Convex.partialtranspose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partialtranspose(x, sys::Int, dims::Vector)</code></pre><p>Returns the partial transpose of <code>x</code> over the <code>sys</code>th system, where <code>dims</code> is a vector of integers encoding the dimensions of each subsystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/reformulations/partialtranspose.jl#L6-L11">source</a></section></article><h2 id="pos"><a class="docs-heading-anchor" href="#pos"><code>pos</code></a><a id="pos-1"></a><a class="docs-heading-anchor-permalink" href="#pos" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.pos-Tuple{Convex.AbstractExpr}" href="#Convex.pos-Tuple{Convex.AbstractExpr}"><code>Convex.pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pos(x::Convex.AbstractExpr)</code></pre><p>The epigraph of <span>$\max(x, 0)$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; pos(x)
max (convex; positive)
├─ real variable (id: 467…111)
└─ [0;;]</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = pos(x)
max (convex; positive)
├─ 3-element real variable (id: 154…809)
└─ [0;;]

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1506-L1537">source</a></section></article><h2 id="qol_elementwise"><a class="docs-heading-anchor" href="#qol_elementwise"><code>qol_elementwise</code></a><a id="qol_elementwise-1"></a><a class="docs-heading-anchor-permalink" href="#qol_elementwise" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.qol_elementwise-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Convex.qol_elementwise-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Convex.qol_elementwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qol_elementwise(x::AbstractExpr, y::AbstractExpr)</code></pre><p>The elementwise epigraph of <span>$\frac{x^2}{y}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; y = Variable(3, Positive());

julia&gt; atom = qol_elementwise(x, y)
qol_elem (convex; positive)
├─ 3-element real variable (id: 155…648)
└─ 3-element positive variable (id: 227…080)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1540-L1560">source</a></section></article><h2 id="quadform"><a class="docs-heading-anchor" href="#quadform"><code>quadform</code></a><a id="quadform-1"></a><a class="docs-heading-anchor-permalink" href="#quadform" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.quadform-Tuple{Union{Number, AbstractArray}, Convex.AbstractExpr}" href="#Convex.quadform-Tuple{Union{Number, AbstractArray}, Convex.AbstractExpr}"><code>Convex.quadform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quadform(x::AbstractExpr, A::AbstractExpr; assume_psd=false)</code></pre><p>Represents <span>$x^\top A x$</span> where either:</p><ul><li><code>x</code> is a vector-valued variable and <code>A</code> is a positive semidefinite or negative semidefinite matrix (and in particular Hermitian or real symmetric). If <code>assume_psd=true</code>, then <code>A</code> will be assumed to be positive semidefinite. Otherwise, <code>Convex._is_psd</code> will be used to check if <code>A</code> is positive semidefinite or negative semidefinite.</li><li>or <code>A</code> is a matrix-valued variable and <code>x</code> is a vector.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2);

julia&gt; A = [1 0; 0 1]
2×2 Matrix{Int64}:
 1  0
 0  1

julia&gt; atom = quadform(x, A)
* (convex; positive)
├─ [1;;]
└─ qol_elem (convex; positive)
   ├─ norm2 (convex; positive)
   │  └─ * (affine; real)
   │     ├─ …
   │     └─ …
   └─ [1.0;;]

julia&gt; size(atom)
(1, 1)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; x = [1, 2]

julia&gt; A = Variable(2, 2);

julia&gt; atom = quadform(x, A)
* (affine; real)
├─ * (affine; real)
│  ├─ [1 2]
│  └─ 2×2 real variable (id: 111…794)
└─ [1; 2;;]

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/reformulations/quadform.jl#L57-L108">source</a></section></article><h2 id="quadoverlin"><a class="docs-heading-anchor" href="#quadoverlin"><code>quadoverlin</code></a><a id="quadoverlin-1"></a><a class="docs-heading-anchor-permalink" href="#quadoverlin" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.quadoverlin-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Convex.quadoverlin-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Convex.quadoverlin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quadoverlin(x::AbstractExpr, y::AbstractExpr)</code></pre><p>The epigraph of <span>$\frac{||x||_2^2}{y}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; y = Variable(Positive());

julia&gt; atom = quadoverlin(x, y)
qol (convex; positive)
├─ 3-element real variable (id: 868…883)
└─ positive variable (id: 991…712)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1563-L1583">source</a></section></article><h2 id="quantum_entropy"><a class="docs-heading-anchor" href="#quantum_entropy"><code>quantum_entropy</code></a><a id="quantum_entropy-1"></a><a class="docs-heading-anchor-permalink" href="#quantum_entropy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.quantum_entropy" href="#Convex.quantum_entropy"><code>Convex.quantum_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quantum_entropy(X::AbstractExpr, m::Integer, k::Integer)</code></pre><p><code>quantum_entropy</code> returns <code>-LinearAlgebra.tr(X*log(X))</code> where <code>X</code> is a positive semidefinite.</p><p>Note this function uses logarithm base e, not base 2, so return value is in units of nats, not bits.</p><p>Quantum entropy is concave. This function implements the semidefinite programming approximation given in the reference below.  Parameters <code>m</code> and <code>k</code> control the accuracy of this approximation: <code>m</code> is the number of quadrature nodes to use and <code>k</code> the number of square-roots to take. See reference for more details.</p><p>The implementation uses the expression</p><p class="math-container">\[H(X) = -tr(D_{op}(X||I))\]</p><p>where <span>$D_{op}$</span> is the operator relative entropy:</p><p class="math-container">\[D_{op}(X||Y) = X^{1/2}*logm(X^{1/2} Y^{-1} X^{1/2})*X^{1/2}\]</p><p><strong>Reference</strong></p><p>Ported from CVXQUAD which is based on the paper: &quot;Lieb&#39;s concavity theorem, matrix geometric means and semidefinite optimization&quot; by Hamza Fawzi and James Saunderson (arXiv:1512.03401)</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; X = Variable(2, 2);

julia&gt; atom = quantum_entropy(X)
quantum_entropy (concave; positive)
└─ 2×2 real variable (id: 700…694)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1586-L1630">source</a></section></article><h2 id="quantum_relative_entropy"><a class="docs-heading-anchor" href="#quantum_relative_entropy"><code>quantum_relative_entropy</code></a><a id="quantum_relative_entropy-1"></a><a class="docs-heading-anchor-permalink" href="#quantum_relative_entropy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.quantum_relative_entropy" href="#Convex.quantum_relative_entropy"><code>Convex.quantum_relative_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quantum_relative_entropy(
    A::AbstractExpr,
    B::AbstractExpr,
    m::Integer,
    k::Integer,
)</code></pre><p><code>quantum_relative_entropy</code> returns <code>LinearAlgebra.tr(A*(log(A)-log(B)))</code> where <code>A</code> and <code>B</code> are positive semidefinite matrices.</p><p>Note this function uses logarithm base e, not base 2, so return value is in units of nats, not bits.</p><p>Quantum relative entropy is convex (jointly) in (A, B). This function implements the semidefinite programming approximation given in the reference below. Parameters m and k control the accuracy of this approximation: <code>m</code> is the number of quadrature nodes to use and <code>k</code> the number of square-roots to take. See reference for more details.</p><p>Implementation uses the expression</p><p class="math-container">\[D(A||B) = e&#39;*D_{op} (A \otimes I || I \otimes B) )*e\]</p><p>where <span>$D_{op}$</span> is the operator relative entropy and <code>e = vec(Matrix(I, n, n))</code>.</p><p><strong>Reference</strong></p><p>Ported from CVXQUAD which is based on the paper: &quot;Lieb&#39;s concavity theorem, matrix geometric means and semidefinite optimization&quot; by Hamza Fawzi and James Saunderson (arXiv:1512.03401)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Variable(2, 2);

julia&gt; B = Variable(2, 2);

julia&gt; atom = quantum_relative_entropy(A, B)
quantum_relative_entropy (convex; positive)
├─ 2×2 real variable (id: 144…849)
└─ 2×2 real variable (id: 969…693)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1643-L1690">source</a></section></article><h2 id="rationalnorm"><a class="docs-heading-anchor" href="#rationalnorm"><code>rationalnorm</code></a><a id="rationalnorm-1"></a><a class="docs-heading-anchor-permalink" href="#rationalnorm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.rationalnorm-Tuple{Convex.AbstractExpr, Rational{Int64}}" href="#Convex.rationalnorm-Tuple{Convex.AbstractExpr, Rational{Int64}}"><code>Convex.rationalnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rationalnorm(x::AbstractExpr, k::Rational{Int})</code></pre><p>The epigraph of <code>||x||_k</code>.</p><p><strong>Examples</strong></p><p>Applies to a single matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2);

julia&gt; atom = rationalnorm(x, 3 // 2)
rationalnorm (convex; positive)
└─ 2-element real variable (id: 182…293)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1759-L1778">source</a></section></article><h2 id="real"><a class="docs-heading-anchor" href="#real"><code>real</code></a><a id="real-1"></a><a class="docs-heading-anchor-permalink" href="#real" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.real-Tuple{Convex.AbstractExpr}" href="#Base.real-Tuple{Convex.AbstractExpr}"><code>Base.real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.real(x::Convex.AbstractExpr)</code></pre><p>Return the real component of <code>x</code>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = ComplexVariable();

julia&gt; real(x)
real (affine; real)
└─ complex variable (id: 407…692)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = ComplexVariable(3);

julia&gt; atom = real(x)
real (affine; real)
└─ 3-element complex variable (id: 435…057)

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1790-L1819">source</a></section></article><h2 id="relative_entropy"><a class="docs-heading-anchor" href="#relative_entropy"><code>relative_entropy</code></a><a id="relative_entropy-1"></a><a class="docs-heading-anchor-permalink" href="#relative_entropy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.relative_entropy-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}" href="#Convex.relative_entropy-Tuple{Convex.AbstractExpr, Convex.AbstractExpr}"><code>Convex.relative_entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_entropy(x::Convex.AbstractExpr, y::Convex.AbstractExpr)</code></pre><p>The epigraph of <span>$\sum x_i*\log \frac{x_i}{y_i}$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; y = Variable();

julia&gt; relative_entropy(x, y)
relative_entropy (convex; real)
├─ real variable (id: 124…372)
└─ real variable (id: 409…346)</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; y = Variable(3);

julia&gt; atom = relative_entropy(x, y)
relative_entropy (convex; real)
├─ 3-element real variable (id: 906…671)
└─ 3-element real variable (id: 118…912)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1826-L1861">source</a></section></article><h2 id="reshape"><a class="docs-heading-anchor" href="#reshape"><code>reshape</code></a><a id="reshape-1"></a><a class="docs-heading-anchor-permalink" href="#reshape" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reshape-Tuple{Convex.AbstractExpr, Int64, Int64}" href="#Base.reshape-Tuple{Convex.AbstractExpr, Int64, Int64}"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.reshape(x::AbstractExpr, m::Int, n::Int)</code></pre><p>Reshapes the expression <code>x</code> into a matrix with <code>m</code> rows and <code>n</code> columns.</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(6, 1);

julia&gt; size(x)
(6, 1)

julia&gt; atom = reshape(x, 2, 3)
reshape (affine; real)
└─ 6-element real variable (id: 103…813)

julia&gt; size(atom)
(2, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1874-L1896">source</a></section></article><h2 id="rootdet"><a class="docs-heading-anchor" href="#rootdet"><code>rootdet</code></a><a id="rootdet-1"></a><a class="docs-heading-anchor-permalink" href="#rootdet" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.rootdet-Tuple{Convex.AbstractExpr}" href="#Convex.rootdet-Tuple{Convex.AbstractExpr}"><code>Convex.rootdet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Convex.rootdet(X::Convex.AbstractExpr)</code></pre><p>The hypograph of <span>$\det(X)^{\frac{1}{n}}$</span>, where <span>$n$</span> is the side-dimension of the square matrix <span>$X$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single matrix expression:</p><pre><code class="language-julia-repl hljs">julia&gt; X = Variable(2, 2);

julia&gt; atom = rootdet(X)
rootdet (concave; real)
└─ 2×2 real variable (id: 159…883)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1899-L1919">source</a></section></article><h2 id="sigmamax"><a class="docs-heading-anchor" href="#sigmamax"><code>sigmamax</code></a><a id="sigmamax-1"></a><a class="docs-heading-anchor-permalink" href="#sigmamax" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.sigmamax-Tuple{Convex.AbstractExpr}" href="#Convex.sigmamax-Tuple{Convex.AbstractExpr}"><code>Convex.sigmamax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sigmamax(x::Convex.AbstractExpr)</code></pre><p>The epigraph of the spectral norm <span>$||X||_2$</span>, which is the maximum of the singular values of <span>$X$</span>.</p><p><strong>Examples</strong></p><p>Applies to a real- or complex-valued matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = sigmamax(x)
opnorm (convex; positive)
└─ 2×2 real variable (id: 106…758)

julia&gt; size(atom)
(1, 1)

julia&gt; y = ComplexVariable(2, 2);

julia&gt; atom = sigmamax(y)
opnorm (convex; positive)
└─ 2×2 complex variable (id: 577…313)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1922-L1951">source</a></section></article><h2 id="sqrt"><a class="docs-heading-anchor" href="#sqrt"><code>sqrt</code></a><a id="sqrt-1"></a><a class="docs-heading-anchor-permalink" href="#sqrt" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sqrt-Tuple{Convex.AbstractExpr}" href="#Base.sqrt-Tuple{Convex.AbstractExpr}"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.sqrt(x::Convex.AbstractExpr)</code></pre><p>The hypograph of <span>$\sqrt x$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable();

julia&gt; sqrt(x)
geomean (concave; positive)
├─ real variable (id: 576…546)
└─ [1.0;;]</code></pre><p>And element-wise to a matrix of expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = sqrt(x)
geomean (concave; positive)
├─ 3-element real variable (id: 181…583)
└─ [1.0; 1.0; 1.0;;]

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1954-L1985">source</a></section></article><h2 id="square"><a class="docs-heading-anchor" href="#square"><code>square</code></a><a id="square-1"></a><a class="docs-heading-anchor-permalink" href="#square" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.square-Tuple{Convex.AbstractExpr}" href="#Convex.square-Tuple{Convex.AbstractExpr}"><code>Convex.square</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">square(x::AbstractExpr)</code></pre><p>The epigraph of <span>$x^2$</span>.</p><p><strong>Examples</strong></p><p>Applies elementwise to a matrix</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = square(x)
qol_elem (convex; positive)
├─ 3-element real variable (id: 438…681)
└─ [1.0; 1.0; 1.0;;]

julia&gt; size(atom)
(3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2124-L2144">source</a></section></article><h2 id="sum"><a class="docs-heading-anchor" href="#sum"><code>sum</code></a><a id="sum-1"></a><a class="docs-heading-anchor-permalink" href="#sum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sum-Tuple{Convex.AbstractExpr}" href="#Base.sum-Tuple{Convex.AbstractExpr}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.sum(x::Convex.AbstractExpr; dims = :)</code></pre><p>Sum <code>x</code>, optionally along a dimension <code>dims</code>.</p><p><strong>Examples</strong></p><p>Sum all elements in an expression:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = sum(x)
sum (affine; real)
└─ 2×2 real variable (id: 263…449)

julia&gt; size(atom)
(1, 1)</code></pre><p>Sum along the first dimension, creating a row vector:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = sum(x; dims = 1)
* (affine; real)
├─ [1.0 1.0]
└─ 2×2 real variable (id: 143…826)

julia&gt; size(atom)
(1, 2)</code></pre><p>Sum along the second dimension, creating a columnn vector:</p><pre><code class="language-julia-repl hljs">julia&gt; atom = sum(x; dims = 2)
* (affine; real)
├─ 2×2 real variable (id: 143…826)
└─ [1.0; 1.0;;]

julia&gt; size(atom)
(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L1990-L2033">source</a></section></article><h2 id="sumlargest"><a class="docs-heading-anchor" href="#sumlargest"><code>sumlargest</code></a><a id="sumlargest-1"></a><a class="docs-heading-anchor-permalink" href="#sumlargest" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.sumlargest-Tuple{Convex.AbstractExpr, Int64}" href="#Convex.sumlargest-Tuple{Convex.AbstractExpr, Int64}"><code>Convex.sumlargest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sumlargest(x::Convex.AbstractExpr, k::Int)</code></pre><p>Sum the <code>k</code> largest values of <code>x</code>.</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3, 3);

julia&gt; atom = sumlargest(x, 2)
sumlargest (convex; real)
├─ 3×3 real variable (id: 833…482)
└─ [2;;]

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2073-L2093">source</a></section></article><h2 id="sumlargesteigs"><a class="docs-heading-anchor" href="#sumlargesteigs"><code>sumlargesteigs</code></a><a id="sumlargesteigs-1"></a><a class="docs-heading-anchor-permalink" href="#sumlargesteigs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.sumlargesteigs-Tuple{Convex.AbstractExpr, Int64}" href="#Convex.sumlargesteigs-Tuple{Convex.AbstractExpr, Int64}"><code>Convex.sumlargesteigs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sumlargesteigs(x::Convex.AbstractExpr, k::Int)</code></pre><p>Sum the <code>k</code> largest eigen values of <code>x</code>.</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3, 3);

julia&gt; atom = sumlargesteigs(x, 2)
sumlargesteigs (convex; real)
├─ 3×3 real variable (id: 833…482)
└─ [2;;]

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2048-L2068">source</a></section></article><h2 id="sumsmallest"><a class="docs-heading-anchor" href="#sumsmallest"><code>sumsmallest</code></a><a id="sumsmallest-1"></a><a class="docs-heading-anchor-permalink" href="#sumsmallest" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.sumsmallest-Tuple{Convex.AbstractExpr, Int64}" href="#Convex.sumsmallest-Tuple{Convex.AbstractExpr, Int64}"><code>Convex.sumsmallest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sumsmallest(x::Convex.AbstractExpr, k::Int)</code></pre><p>Sum the <code>k</code> smallest values of <code>x</code>.</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3, 3);

julia&gt; atom = sumsmallest(x, 2)
Convex.NegateAtom (concave; real)
└─ sumlargest (convex; real)
   └─ Convex.NegateAtom (affine; real)
      └─ 3×3 real variable (id: 723…082)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2098-L2119">source</a></section></article><h2 id="sumsquares"><a class="docs-heading-anchor" href="#sumsquares"><code>sumsquares</code></a><a id="sumsquares-1"></a><a class="docs-heading-anchor-permalink" href="#sumsquares" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.sumsquares-Tuple{Convex.AbstractExpr}" href="#Convex.sumsquares-Tuple{Convex.AbstractExpr}"><code>Convex.sumsquares</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sumsquares(x::AbstractExpr)</code></pre><p>The epigraph of <span>$||x||_2^2$</span>.</p><p><strong>Examples</strong></p><p>Applies to a single matrix</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(3);

julia&gt; atom = sumsquares(x)
qol (convex; positive)
├─ 3-element real variable (id: 125…181)
└─ [1;;]

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2154-L2174">source</a></section></article><h2 id="tr"><a class="docs-heading-anchor" href="#tr"><code>tr</code></a><a id="tr-1"></a><a class="docs-heading-anchor-permalink" href="#tr" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.tr-Tuple{Convex.AbstractExpr}" href="#LinearAlgebra.tr-Tuple{Convex.AbstractExpr}"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.tr(x::AbstractExpr)</code></pre><p>The trace of the matrix <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = tr(x)
sum (affine; real)
└─ diag (affine; real)
   └─ 2×2 real variable (id: 844…180)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2182-L2200">source</a></section></article><h2 id="trace_logm"><a class="docs-heading-anchor" href="#trace_logm"><code>trace_logm</code></a><a id="trace_logm-1"></a><a class="docs-heading-anchor-permalink" href="#trace_logm" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.trace_logm" href="#Convex.trace_logm"><code>Convex.trace_logm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trace_logm(
    X::Convex.AbstractExpr,
    C::AbstractMatrix,
    m::Integer = 3,
    k::Integer = 3,
)</code></pre><p><code>trace_logm(X, C)</code> returns <code>LinearAlgebra.tr(C*logm(X))</code> where <code>X</code> and <code>C</code> are positive definite matrices and <code>C</code> is constant.</p><p><code>trace_logm</code> is concave in <code>X</code>.</p><p>This function implements the semidefinite programming approximation given in the reference below. Parameters <code>m</code> and <code>k</code> control the accuracy of the approximation: <code>m</code> is the number of quadrature nodes to use and <code>k</code> is the number of square-roots to take. See reference for more details.</p><p>Implementation uses the expression</p><p class="math-container">\[tr(C \times logm(X)) = -tr(C \times D_{op}(I||X))\]</p><p>where <code>D_{op}</code> is the operator relative entropy:</p><p class="math-container">\[D_{op}(X||Y) = X^{1/2}*logm(X^{1/2} Y^{-1} X^{1/2})*X^{1/2}\]</p><p><strong>Reference</strong></p><p>Ported from CVXQUAD which is based on the paper: &quot;Lieb&#39;s concavity theorem, matrix geometric means and semidefinite optimization&quot; by Hamza Fawzi and James Saunderson (arXiv:1512.03401)</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; X = Variable(2, 2);

julia&gt; C = [1 0; 0 1];

julia&gt; atom = trace_logm(X, C)
trace_logm (concave; real)
└─ 2×2 real variable (id: 608…362)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2203-L2253">source</a></section></article><h2 id="trace_mpower"><a class="docs-heading-anchor" href="#trace_mpower"><code>trace_mpower</code></a><a id="trace_mpower-1"></a><a class="docs-heading-anchor-permalink" href="#trace_mpower" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Convex.trace_mpower-Tuple{Convex.AbstractExpr, Rational, Union{Convex.Constant, AbstractMatrix}}" href="#Convex.trace_mpower-Tuple{Convex.AbstractExpr, Rational, Union{Convex.Constant, AbstractMatrix}}"><code>Convex.trace_mpower</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trace_mpower(A::Convex.AbstractExpr, t::Rational, C::AbstractMatrix)</code></pre><p><code>trace_mpower(A, t, C)</code> returns <code>LinearAlgebra.tr(C*A^t)</code> where <code>A</code> and <code>C</code> are positive definite matrices, <code>C</code> is constant and <code>t</code> is a rational in <code>[-1, 2]</code>.</p><p>When <code>t</code> is in <code>[0, 1]</code>, <code>trace_mpower(A, t, C)</code> is concave in <code>A</code> (for fixed positive semidefinite matrix <code>C</code>) and convex for <code>t</code> in <code>[-1, 0)</code> or <code>(1, 2]</code>.</p><p><strong>Reference</strong></p><p>Ported from CVXQUAD which is based on the paper: &quot;Lieb&#39;s concavity theorem, matrix geometric means and semidefinite optimization&quot; by Hamza Fawzi and James Saunderson (arXiv:1512.03401)</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; A = Variable(2, 2);

julia&gt; C = [1 0; 0 1];

julia&gt; atom = trace_mpower(A, 1 // 2, C)
trace_mpower (concave; real)
└─ 2×2 real variable (id: 150…626)

julia&gt; size(atom)
(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2275-L2306">source</a></section></article><h2 id="transpose"><a class="docs-heading-anchor" href="#transpose"><code>transpose</code></a><a id="transpose-1"></a><a class="docs-heading-anchor-permalink" href="#transpose" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.transpose-Tuple{Convex.AbstractExpr}" href="#Base.transpose-Tuple{Convex.AbstractExpr}"><code>Base.transpose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.transpose(x::AbstractExpr)</code></pre><p>The transpose of the matrix <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = transpose(x)
reshape (affine; real)
└─ * (affine; real)
   ├─ 4×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 4 stored entries
   └─ reshape (affine; real)
      └─ 2×2 real variable (id: 151…193)

julia&gt; size(atom)
(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2333-L2353">source</a></section></article><h2 id="vcat"><a class="docs-heading-anchor" href="#vcat"><code>vcat</code></a><a id="vcat-1"></a><a class="docs-heading-anchor-permalink" href="#vcat" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.vcat-Tuple{Vararg{Convex.AbstractExpr}}" href="#Base.vcat-Tuple{Vararg{Convex.AbstractExpr}}"><code>Base.vcat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.vcat(args::AbstractExpr...)</code></pre><p>Vertically concatenate <code>args</code>.</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = vcat(x, x)
vcat (affine; real)
├─ 2×2 real variable (id: 111…376)
└─ 2×2 real variable (id: 111…376)

julia&gt; size(atom)
(4, 2)</code></pre><p>You can also use the Julia <code>[x; x]</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = [x; x]
vcat (affine; real)
├─ 2×2 real variable (id: 111…376)
└─ 2×2 real variable (id: 111…376)

julia&gt; size(atom)
(4, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2364-L2398">source</a></section></article><h2 id="vec"><a class="docs-heading-anchor" href="#vec"><code>vec</code></a><a id="vec-1"></a><a class="docs-heading-anchor-permalink" href="#vec" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.vec-Tuple{Convex.AbstractExpr}" href="#Base.vec-Tuple{Convex.AbstractExpr}"><code>Base.vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.vec(x::AbstractExpr)</code></pre><p>Reshapes the expression <code>x</code> into a column vector.</p><p><strong>Examples</strong></p><p>Applies to a matrix:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Variable(2, 2);

julia&gt; atom = vec(x)
reshape (affine; real)
└─ 2×2 real variable (id: 115…295)

julia&gt; size(atom)
(4, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/Convex.jl/blob/64391581c233875bf6746db2e8b0693ec675d41e/src/supported_operations.jl#L2408-L2427">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><a class="docs-footer-nextpage" href="../../release_notes/">Release notes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 18 June 2024 07:18">Tuesday 18 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
