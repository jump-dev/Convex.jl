<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Supported Operations · Convex.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Convex.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../introduction/installation/">Installation</a></li><li><a class="tocitem" href="../../introduction/quick_tutorial/">Quick Tutorial</a></li><li><a class="tocitem" href="../../introduction/faq/">FAQ</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">General examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/general_examples/DCP_analysis/">DCP analysis</a></li><li><a class="tocitem" href="../../examples/general_examples/basic_usage/">Basic Usage</a></li><li><a class="tocitem" href="../../examples/general_examples/chebyshev_center/">Chebyshev center</a></li><li><a class="tocitem" href="../../examples/general_examples/control/">Control</a></li><li><a class="tocitem" href="../../examples/general_examples/huber_regression/">Huber regression</a></li><li><a class="tocitem" href="../../examples/general_examples/lasso_regression/">Lasso, Ridge and Elastic Net Regressions</a></li><li><a class="tocitem" href="../../examples/general_examples/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../examples/general_examples/max_entropy/">Entropy Maximization</a></li><li><a class="tocitem" href="../../examples/general_examples/optimal_advertising/">Optimal advertising</a></li><li><a class="tocitem" href="../../examples/general_examples/robust_approx_fitting/">Robust approximate fitting</a></li><li><a class="tocitem" href="../../examples/general_examples/svm/">Support vector machine</a></li><li><a class="tocitem" href="../../examples/general_examples/svm_l1regularization/">SVM with L^1 regularization</a></li><li><a class="tocitem" href="../../examples/general_examples/trade_off_curves/">Trade-off curves</a></li><li><a class="tocitem" href="../../examples/general_examples/worst_case_analysis/">Worst case risk analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Mixed integer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/mixed_integer/binary_knapsack/">Binary (or 0-1) knapsack problem</a></li><li><a class="tocitem" href="../../examples/mixed_integer/n_queens/">N queens</a></li><li><a class="tocitem" href="../../examples/mixed_integer/section_allocation/">Section Allocation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Optimization with complex variables</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/optimization_with_complex_variables/Fidelity in Quantum Information Theory/">Fidelity in quantum information theory</a></li><li><a class="tocitem" href="../../examples/optimization_with_complex_variables/phase_recovery_using_MaxCut/">Phase recovery using MaxCut</a></li><li><a class="tocitem" href="../../examples/optimization_with_complex_variables/povm_simulation/">POVM simulation</a></li><li><a class="tocitem" href="../../examples/optimization_with_complex_variables/power_flow_optimization/">Power flow optimization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Portfolio optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/portfolio_optimization/portfolio_optimization/">Portfolio Optimization</a></li><li><a class="tocitem" href="../../examples/portfolio_optimization/portfolio_optimization2/">Portfolio Optimization - Markowitz Efficient Frontier</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Supplemental material</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/supplemental_material/Convex.jl_intro_ISMP2015/">Convex Optimization in Julia</a></li><li><a class="tocitem" href="../../examples/supplemental_material/paper_examples/">Paper examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Time series</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/time_series/time_series/">Time Series Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-7" type="checkbox"/><label class="tocitem" for="menuitem-2-7"><span class="docs-label">Tomography</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/tomography/tomography/">Tomography</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../types/">Basic Types</a></li><li class="is-active"><a class="tocitem" href>Supported Operations</a><ul class="internal"><li><a class="tocitem" href="#Linear-Program-Representable-Functions"><span>Linear Program Representable Functions</span></a></li><li><a class="tocitem" href="#Second-Order-Cone-Representable-Functions"><span>Second-Order Cone Representable Functions</span></a></li><li><a class="tocitem" href="#Exponential-Cone-Representable-Functions"><span>Exponential Cone Representable Functions</span></a></li><li><a class="tocitem" href="#Semidefinite-Program-Representable-Functions"><span>Semidefinite Program Representable Functions</span></a></li><li><a class="tocitem" href="#Exponential-SDP-representable-Functions"><span>Exponential + SDP representable Functions</span></a></li><li><a class="tocitem" href="#Promotions"><span>Promotions</span></a></li></ul></li><li><a class="tocitem" href="../complex-domain_optimization/">Complex-domain Optimization</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../advanced/">Advanced Features</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developer/problem_depot/">Problem Depot</a></li><li><a class="tocitem" href="../../developer/contributing/">Contributing</a></li><li><a class="tocitem" href="../../developer/credits/">Credits</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Supported Operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Supported Operations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/Convex.jl/blob/master/docs/src/manual/operations.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Supported-Operations"><a class="docs-heading-anchor" href="#Supported-Operations">Supported Operations</a><a id="Supported-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-Operations" title="Permalink"></a></h1><p>Convex.jl currently supports the following functions. These functions may be composed according to the <a href="http://dcp.stanford.edu">DCP</a> composition rules to form new convex, concave, or affine expressions.</p><p>Convex.jl transforms each problem into an equivalent conic program in order to pass the problem to a specialized solver. Depending on the types of functions used in the problem, the conic constraints may include linear, second-order, exponential, or semidefinite constraints, as well as any binary or integer constraints placed on the variables.</p><p>Below, we list each function available in Convex.jl organized by the (most complex) type of cone used to represent that function, and indicate which solvers may be used to solve problems with those cones. Problems mixing many different conic constraints can be solved by any solver that supports every kind of cone present in the problem.</p><p>In the notes column in the tables below, we denote implicit constraints imposed on the arguments to the function by IC, and parameter restrictions that the arguments must obey by PR. Convex.jl will automatically impose ICs; the user must make sure to satisfy PRs.</p><p>Elementwise means that the function operates elementwise on vector arguments, returning a vector of the same size.</p><h2 id="Linear-Program-Representable-Functions"><a class="docs-heading-anchor" href="#Linear-Program-Representable-Functions">Linear Program Representable Functions</a><a id="Linear-Program-Representable-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Program-Representable-Functions" title="Permalink"></a></h2><p>An optimization problem using only these functions can be solved by any LP solver.</p><table><tr><th style="text-align: left">operation</th><th style="text-align: left">description</th><th style="text-align: left">vexity</th><th style="text-align: left">slope</th><th style="text-align: left">notes</th></tr><tr><td style="text-align: left"><code>x+y</code> or <code>x.+y</code></td><td style="text-align: left">addition</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>x-y</code> or <code>x.-y</code></td><td style="text-align: left">subtraction</td><td style="text-align: left">affine</td><td style="text-align: left">increasing in <span>$x$</span> decreasing in <span>$y$</span></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>x*y</code></td><td style="text-align: left">multiplication</td><td style="text-align: left">affine</td><td style="text-align: left">increasing if constant term <span>$\ge 0$</span> decreasing if constant term <span>$\le 0$</span> not monotonic otherwise</td><td style="text-align: left">PR: one argument is constant</td></tr><tr><td style="text-align: left"><code>x/y</code></td><td style="text-align: left">division</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left">PR: <span>$y$</span> is scalar constant</td></tr><tr><td style="text-align: left"><code>x .* y</code></td><td style="text-align: left">elementwise multiplication</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left">PR: one argument is constant</td></tr><tr><td style="text-align: left"><code>x ./ y</code></td><td style="text-align: left">elementwise division</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left">PR: one argument is constant</td></tr><tr><td style="text-align: left"><code>x[1:4, 2:3]</code></td><td style="text-align: left">indexing and slicing</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>diag(x, k)</code></td><td style="text-align: left"><span>$k$</span>-th diagonal of a matrix</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>diagm(x)</code></td><td style="text-align: left">construct diagonal matrix</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left">PR: <span>$x$</span> is a vector</td></tr><tr><td style="text-align: left"><code>x&#39;</code></td><td style="text-align: left">transpose</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>vec(x)</code></td><td style="text-align: left">vector representation</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>dot(x,y)</code></td><td style="text-align: left"><span>$\sum_i x_i y_i$</span></td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left">PR: one argument is constant</td></tr><tr><td style="text-align: left"><code>kron(x,y)</code></td><td style="text-align: left">Kronecker product</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left">PR: one argument is constant</td></tr><tr><td style="text-align: left"><code>sum(x)</code></td><td style="text-align: left"><span>$\sum_{ij} x_{ij}$</span></td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>sum(x, k)</code></td><td style="text-align: left">sum elements across dimension <span>$k$</span></td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>sumlargest(x, k)</code></td><td style="text-align: left">sum of <span>$k$</span> largest elements of <span>$x$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>sumsmallest(x, k)</code></td><td style="text-align: left">sum of <span>$k$</span> smallest elements of <span>$x$</span></td><td style="text-align: left">concave</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>dotsort(a, b)</code></td><td style="text-align: left"><code>dot(sort(a),sort(b))</code></td><td style="text-align: left">convex</td><td style="text-align: left">increasing</td><td style="text-align: left">PR: one argument is constant</td></tr><tr><td style="text-align: left"><code>reshape(x, m, n)</code></td><td style="text-align: left">reshape into <span>$m \times n$</span></td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>minimum(x)</code></td><td style="text-align: left"><span>$\min(x)$</span></td><td style="text-align: left">concave</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>maximum(x)</code></td><td style="text-align: left"><span>$\max(x)$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>[x y]</code> or <code>[x; y]</code> <code>hcat(x, y)</code> or <code>vcat(x, y)</code></td><td style="text-align: left">stacking</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>tr(x)</code></td><td style="text-align: left">computes the trace <span>$\mathrm{tr} \left(X \right)$</span></td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>partialtrace(x,sys,dims)</code></td><td style="text-align: left">Partial trace</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>partialtranspose(x,sys,dims)</code></td><td style="text-align: left">Partial transpose</td><td style="text-align: left">affine</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>conv(h,x)</code></td><td style="text-align: left"><span>$h \in \mathbb{R}^m$</span>, <span>$x \in \mathbb{R}^n$</span>, <span>$h\star x \in \mathbb{R}^{m+n-1}$</span>; entry <span>$i$</span> is given by <span>$\sum_{j=1}^m h_jx_{i-j+1}$</span> with <span>$x_k=0$</span> for <span>$k$</span> out of bounds</td><td style="text-align: left">affine</td><td style="text-align: left">increasing if <span>$h\ge 0$</span> decreasing if <span>$h\le 0$</span> not monotonic otherwise</td><td style="text-align: left">PR: <span>$h$</span> is constant</td></tr><tr><td style="text-align: left"><code>min(x,y)</code></td><td style="text-align: left"><span>$\min(x,y)$</span></td><td style="text-align: left">concave</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>max(x,y)</code></td><td style="text-align: left"><span>$\max(x,y)$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>pos(x)</code></td><td style="text-align: left"><span>$\max(x,0)$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>neg(x)</code></td><td style="text-align: left"><span>$\max(-x,0)$</span></td><td style="text-align: left">convex</td><td style="text-align: left">decreasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>invpos(x)</code></td><td style="text-align: left"><span>$1/x$</span></td><td style="text-align: left">convex</td><td style="text-align: left">decreasing</td><td style="text-align: left">IC: <span>$x&gt;0$</span></td></tr><tr><td style="text-align: left"><code>abs(x)</code></td><td style="text-align: left"><span>$\left|x\right|$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing on <span>$x \ge 0$</span> decreasing on <span>$x \le 0$</span></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>opnorm(x, 1)</code></td><td style="text-align: left">maximum absolute column sum: <span>$\max_{1 ≤ j ≤ n} \sum_{i=1}^m \left|x_{ij}\right|$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing on <span>$x \ge 0$</span> decreasing on <span>$x \le 0$</span></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>opnorm(x, Inf)</code></td><td style="text-align: left">maximum absolute row sum: <span>$\max_{1 ≤ i ≤ m} \sum_{j=1}^n \left|x_{ij}\right|$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing on <span>$x \ge 0$</span> decreasing on <span>$x \le 0$</span></td><td style="text-align: left"></td></tr></table><h2 id="Second-Order-Cone-Representable-Functions"><a class="docs-heading-anchor" href="#Second-Order-Cone-Representable-Functions">Second-Order Cone Representable Functions</a><a id="Second-Order-Cone-Representable-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Second-Order-Cone-Representable-Functions" title="Permalink"></a></h2><p>An optimization problem using these functions can be solved by any SOCP solver (including ECOS, SCS, Mosek, Gurobi, and CPLEX). Of course, if an optimization problem has both LP and SOCP representable functions, then any solver that can solve both LPs and SOCPs can solve the problem.</p><table><tr><th style="text-align: left">operation</th><th style="text-align: left">description</th><th style="text-align: left">vexity</th><th style="text-align: left">slope</th><th style="text-align: left">notes</th></tr><tr><td style="text-align: left"><code>norm(x, p)</code></td><td style="text-align: left"><span>$(\sum |x_i|^p)^{1/p}$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing on <span>$x \ge 0$</span> decreasing on <span>$x \le 0$</span></td><td style="text-align: left">PR: <code>p &gt;= 1</code></td></tr><tr><td style="text-align: left"><code>quadform(x, P; assume_psd=false)</code></td><td style="text-align: left"><span>$x^T P x$</span></td><td style="text-align: left">convex in <span>$x$</span> affine in <span>$P$</span></td><td style="text-align: left">increasing on <span>$x \ge 0$</span> decreasing on <span>$x \le 0$</span> increasing in <span>$P$</span></td><td style="text-align: left">PR: either <span>$x$</span> or <span>$P$</span> must be constant; if <span>$x$</span> is not constant, then <span>$P$</span> must be symmetric and positive semidefinite. Pass <code>assume_psd=true</code> to skip checking if <code>P</code> is positive semidefinite.</td></tr><tr><td style="text-align: left"><code>quadoverlin(x, y)</code></td><td style="text-align: left"><span>$x^T x/y$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing on <span>$x \ge 0$</span> decreasing on <span>$x \le 0$</span> decreasing in <span>$y$</span></td><td style="text-align: left">IC: <span>$y &gt; 0$</span></td></tr><tr><td style="text-align: left"><code>sumsquares(x)</code></td><td style="text-align: left"><span>$\sum x_i^2$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing on <span>$x \ge 0$</span> decreasing on <span>$x \le 0$</span></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>sqrt(x)</code></td><td style="text-align: left"><span>$\sqrt{x}$</span></td><td style="text-align: left">concave</td><td style="text-align: left">decreasing</td><td style="text-align: left">IC: <span>$x&gt;0$</span></td></tr><tr><td style="text-align: left"><code>square(x), x^2</code></td><td style="text-align: left"><span>$x^2$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing on <span>$x \ge 0$</span> decreasing on <span>$x \le 0$</span></td><td style="text-align: left">PR : <span>$x$</span> is scalar</td></tr><tr><td style="text-align: left"><code>x .^ 2</code></td><td style="text-align: left"><span>$x.^2$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing on <span>$x \ge 0$</span> decreasing on <span>$x \le 0$</span></td><td style="text-align: left">elementwise</td></tr><tr><td style="text-align: left"><code>geomean(x, y)</code></td><td style="text-align: left"><span>$\sqrt{xy}$</span></td><td style="text-align: left">concave</td><td style="text-align: left">increasing</td><td style="text-align: left">IC: <span>$x\ge0$</span>, <span>$y\ge0$</span></td></tr><tr><td style="text-align: left"><code>huber(x, M=1)</code></td><td style="text-align: left"><span>$\begin{cases} x^2 &amp;|x| \leq M \\ 2M|x| - M^2 &amp;|x| &gt; M \end{cases}$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing on <span>$x \ge 0$</span> decreasing on <span>$x \le 0$</span></td><td style="text-align: left">PR: <span>$M&gt;=1$</span></td></tr></table><p>Note that for <code>p=1</code> and <code>p=Inf</code>, the function <code>norm(x,p)</code> is a linear-program representable, and does not need a SOCP solver, and for a matrix <code>x</code>, <code>norm(x,p)</code> is defined as <code>norm(vec(x), p)</code>.</p><h2 id="Exponential-Cone-Representable-Functions"><a class="docs-heading-anchor" href="#Exponential-Cone-Representable-Functions">Exponential Cone Representable Functions</a><a id="Exponential-Cone-Representable-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exponential-Cone-Representable-Functions" title="Permalink"></a></h2><p>An optimization problem using these functions can be solved by any exponential cone solver (SCS).</p><table><tr><th style="text-align: left">operation</th><th style="text-align: left">description</th><th style="text-align: left">vexity</th><th style="text-align: left">slope</th><th style="text-align: left">notes</th></tr><tr><td style="text-align: left"><code>logsumexp(x)</code></td><td style="text-align: left"><span>$\log(\sum_i \exp(x_i))$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>exp(x)</code></td><td style="text-align: left"><span>$\exp(x)$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>log(x)</code></td><td style="text-align: left"><span>$\log(x)$</span></td><td style="text-align: left">concave</td><td style="text-align: left">increasing</td><td style="text-align: left">IC: <span>$x&gt;0$</span></td></tr><tr><td style="text-align: left"><code>entropy(x)</code></td><td style="text-align: left"><span>$\sum_{ij} -x_{ij} \log(x_{ij})$</span></td><td style="text-align: left">concave</td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: <span>$x&gt;0$</span></td></tr><tr><td style="text-align: left"><code>entropy_elementwise(x)</code></td><td style="text-align: left"><span>$-x \log(x)$</span></td><td style="text-align: left">concave</td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: <span>$x&gt;0$</span></td></tr><tr><td style="text-align: left"><code>logisticloss(x)</code></td><td style="text-align: left"><span>$\log(1 + \exp(x_i))$</span></td><td style="text-align: left">convex</td><td style="text-align: left">increasing</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>relative_entropy(x, y)</code></td><td style="text-align: left"><span>$\sum_i x_i \log(x_i / y_i)$</span></td><td style="text-align: left">convex</td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: <span>$x&gt;0, y&gt;0$</span></td></tr></table><h2 id="Semidefinite-Program-Representable-Functions"><a class="docs-heading-anchor" href="#Semidefinite-Program-Representable-Functions">Semidefinite Program Representable Functions</a><a id="Semidefinite-Program-Representable-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Semidefinite-Program-Representable-Functions" title="Permalink"></a></h2><p>An optimization problem using these functions can be solved by any SDP solver (including SCS and Mosek).</p><table><tr><th style="text-align: left">operation</th><th style="text-align: left">description</th><th style="text-align: left">vexity</th><th style="text-align: left">slope</th><th style="text-align: left">notes</th></tr><tr><td style="text-align: left"><code>nuclearnorm(x)</code></td><td style="text-align: left">sum of singular values of <span>$x$</span></td><td style="text-align: left">convex</td><td style="text-align: left">not monotonic</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>opnorm(x, 2)</code> (<code>operatornorm(x)</code>)</td><td style="text-align: left">max of singular values of <span>$x$</span></td><td style="text-align: left">convex</td><td style="text-align: left">not monotonic</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>eigmax(x)</code></td><td style="text-align: left">max eigenvalue of <span>$x$</span></td><td style="text-align: left">convex</td><td style="text-align: left">not monotonic</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>eigmin(x)</code></td><td style="text-align: left">min eigenvalue of <span>$x$</span></td><td style="text-align: left">concave</td><td style="text-align: left">not monotonic</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>rootdet(X)</code></td><td style="text-align: left">n-th root-determinant of the <span>$n$</span>-by-<span>$n$</span> matrix X, that is <span>$det(X)^{1/n}$</span></td><td style="text-align: left">concave</td><td style="text-align: left">not monotonic</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>matrixfrac(x, P)</code></td><td style="text-align: left"><span>$x^TP^{-1}x$</span></td><td style="text-align: left">convex</td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: P is positive semidefinite</td></tr><tr><td style="text-align: left"><code>sumlargesteigs(x, k)</code></td><td style="text-align: left">sum of top <span>$k$</span> eigenvalues of <span>$x$</span></td><td style="text-align: left">convex</td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: P symmetric</td></tr><tr><td style="text-align: left"><code>T in GeometricMeanHypoCone(A, B, t)</code></td><td style="text-align: left"><span>$T \preceq A \#_t B = A^{1/2} (A^{-1/2} B A^{-1/2})^t A^{1/2}$</span></td><td style="text-align: left">concave</td><td style="text-align: left">increasing</td><td style="text-align: left">IC: <span>$A \succeq 0$</span>, <span>$B \succeq 0$</span>, <span>$t \in [0,1]$</span></td></tr><tr><td style="text-align: left"><code>Convex.GenericConstraint((T, A, B), GeometricMeanEpiConeSquare(t, size(T, 1)))</code></td><td style="text-align: left"><span>$T \succeq A \#_t B = A^{1/2} (A^{-1/2} B A^{-1/2})^t A^{1/2}$</span></td><td style="text-align: left">convex</td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: <span>$A \succeq 0$</span>, <span>$B \succeq 0$</span>, <span>$t \in [-1, 0] \cup [1, 2]$</span></td></tr><tr><td style="text-align: left"><code>quantum_entropy(X)</code></td><td style="text-align: left"><span>$-\textrm{Tr}(X \log X)$</span></td><td style="text-align: left">concave</td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: <span>$X \succeq 0$</span>; uses natural log</td></tr><tr><td style="text-align: left"><code>quantum_relative_entropy(A, B)</code></td><td style="text-align: left"><span>$\textrm{Tr}(A \log A - A \log B)$</span></td><td style="text-align: left">convex</td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: <span>$A \succeq 0$</span>, <span>$B \succeq 0$</span>; uses natural log</td></tr><tr><td style="text-align: left"><code>trace_logm(X, C)</code></td><td style="text-align: left"><span>$\textrm{Tr}(C \log X)$</span></td><td style="text-align: left">concave in X</td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: <span>$X \succeq 0$</span>, <span>$C \succeq 0$</span>, <span>$C$</span> constant; uses natural log</td></tr><tr><td style="text-align: left"><code>trace_mpower(A, t, C)</code></td><td style="text-align: left"><span>$\textrm{Tr}(C A^t)$</span></td><td style="text-align: left">concave in A for <span>$t \in [0,1]$</span>, convex for <span>$t \in [-1,0] \cup [1,2]$</span></td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: <span>$X \succeq 0$</span>, <span>$C \succeq 0$</span>, <span>$C$</span> constant, <span>$t \in [-1, 2]$</span></td></tr><tr><td style="text-align: left"><code>lieb_ando(A, B, K, t)</code></td><td style="text-align: left"><span>$\textrm{Tr}(K&#39; A^{1-t} K B^t)$</span></td><td style="text-align: left">concave in A,B for <span>$t \in [0,1]$</span>, convex for <span>$t \in [-1,0] \cup [1,2]$</span></td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: <span>$A \succeq 0$</span>, <span>$B \succeq 0$</span>, <span>$K$</span> constant, <span>$t \in [-1, 2]$</span></td></tr><tr><td style="text-align: left"><code>T in RelativeEntropyEpiCone(X, Y, m, k, e)</code></td><td style="text-align: left"><span>$T \succeq e&#39; X^{1/2} \log(X^{1/2} Y^{-1} X^{1/2}) X^{1/2} e$</span></td><td style="text-align: left">convex</td><td style="text-align: left">not monotonic</td><td style="text-align: left">IC: <span>$e$</span> constant; uses natural log</td></tr></table><h2 id="Exponential-SDP-representable-Functions"><a class="docs-heading-anchor" href="#Exponential-SDP-representable-Functions">Exponential + SDP representable Functions</a><a id="Exponential-SDP-representable-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exponential-SDP-representable-Functions" title="Permalink"></a></h2><p>An optimization problem using these functions can be solved by any solver that supports exponential constraints <em>and</em> semidefinite constraints simultaneously (SCS).</p><table><tr><th style="text-align: left">operation</th><th style="text-align: left">description</th><th style="text-align: left">vexity</th><th style="text-align: left">slope</th><th style="text-align: left">notes</th></tr><tr><td style="text-align: left"><code>logdet(x)</code></td><td style="text-align: left">log of determinant of <span>$x$</span></td><td style="text-align: left">concave</td><td style="text-align: left">increasing</td><td style="text-align: left">IC: x is positive semidefinite</td></tr></table><h2 id="Promotions"><a class="docs-heading-anchor" href="#Promotions">Promotions</a><a id="Promotions-1"></a><a class="docs-heading-anchor-permalink" href="#Promotions" title="Permalink"></a></h2><p>When an atom or constraint is applied to a scalar and a higher dimensional variable, the scalars are promoted. For example, we can do <code>max(x, 0)</code> gives an expression with the shape of <code>x</code> whose elements are the maximum of the corresponding element of <code>x</code> and <code>0</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Basic Types</a><a class="docs-footer-nextpage" href="../complex-domain_optimization/">Complex-domain Optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 9 May 2024 22:53">Thursday 9 May 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
