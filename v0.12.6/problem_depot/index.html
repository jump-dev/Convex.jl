<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Problem Depot · Convex.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><h1>Convex.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../quick_tutorial/">Quick Tutorial</a></li><li><a class="toctext" href="../types/">Basic Types</a></li><li><a class="toctext" href="../operations/">Supported Operations</a></li><li><a class="toctext" href="../complex-domain_optimization/">Complex-domain Optimization</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li><li><a class="toctext" href="../faq/">FAQ</a></li><li><a class="toctext" href="../advanced/">Advanced</a></li><li class="current"><a class="toctext" href="">Problem Depot</a><ul class="internal"><li><a class="toctext" href="#How-to-write-a-ProblemDepot-problem-1">How to write a ProblemDepot problem</a></li><li><a class="toctext" href="#Benchmark-only-problems-1">Benchmark-only problems</a></li><li><a class="toctext" href="#Reference-1">Reference</a></li></ul></li><li><a class="toctext" href="../contributing/">Contributing</a></li><li><a class="toctext" href="../credits/">Credits</a></li><li><span class="toctext">Examples</span><ul><li><span class="toctext">General examples</span><ul><li><a class="toctext" href="../examples/general_examples/DCP_analysis/">DCP analysis</a></li><li><a class="toctext" href="../examples/general_examples/basic_usage/">Basic Usage</a></li><li><a class="toctext" href="../examples/general_examples/chebyshev_center/">Chebyshev center</a></li><li><a class="toctext" href="../examples/general_examples/control/">Control</a></li><li><a class="toctext" href="../examples/general_examples/huber_regression/">Huber regression</a></li><li><a class="toctext" href="../examples/general_examples/logistic_regression/">Logistic regression</a></li><li><a class="toctext" href="../examples/general_examples/max_entropy/">Entropy Maximization</a></li><li><a class="toctext" href="../examples/general_examples/optimal_advertising/">Optimal advertising</a></li><li><a class="toctext" href="../examples/general_examples/robust_approx_fitting/">Robust approximate fitting</a></li><li><a class="toctext" href="../examples/general_examples/svm/">Support vector machine</a></li><li><a class="toctext" href="../examples/general_examples/svm_l1regularization/">SVM with L^1 regularization</a></li><li><a class="toctext" href="../examples/general_examples/trade_off_curves/">Trade-off curves</a></li><li><a class="toctext" href="../examples/general_examples/worst_case_analysis/">Worst case risk analysis</a></li></ul></li><li><span class="toctext">Mixed integer</span><ul><li><a class="toctext" href="../examples/mixed_integer/binary_knapsack/">Binary (or 0-1) knapsack problem</a></li><li><a class="toctext" href="../examples/mixed_integer/n_queens/">N queens</a></li><li><a class="toctext" href="../examples/mixed_integer/section_allocation/">Section Allocation</a></li></ul></li><li><span class="toctext">Optimization with complex variables</span><ul><li><a class="toctext" href="../examples/optimization_with_complex_variables/Fidelity in Quantum Information Theory/">Fidelity in quantum information theory</a></li><li><a class="toctext" href="../examples/optimization_with_complex_variables/phase_recovery_using_MaxCut/">Phase recovery using MaxCut</a></li><li><a class="toctext" href="../examples/optimization_with_complex_variables/povm_simulation/">POVM simulation</a></li><li><a class="toctext" href="../examples/optimization_with_complex_variables/power_flow_optimization/">Power flow optimization</a></li></ul></li><li><span class="toctext">Portfolio optimization</span><ul><li><a class="toctext" href="../examples/portfolio_optimization/portfolio_optimization/">Portfolio Optimization</a></li><li><a class="toctext" href="../examples/portfolio_optimization/portfolio_optimization2/">Portfolio Optimization - Markowitz Efficient Frontier</a></li></ul></li><li><span class="toctext">Supplemental material</span><ul><li><a class="toctext" href="../examples/supplemental_material/Convex.jl_intro_ISMP2015/">Convex Optimization in Julia</a></li><li><a class="toctext" href="../examples/supplemental_material/paper_examples/">Paper examples</a></li></ul></li><li><span class="toctext">Time series</span><ul><li><a class="toctext" href="../examples/time_series/time_series/">Time Series Analysis</a></li></ul></li><li><span class="toctext">Tomography</span><ul><li><a class="toctext" href="../examples/tomography/tomography/">Tomography</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="">Problem Depot</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/Convex.jl/blob/master/docs/src/problem_depot.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Problem Depot</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Problem-Depot-1" id="Problem-Depot-1">Problem Depot</a></h1><p>Convex.jl has a submodule, <code>ProblemDepot</code> which holds a collection of convex optimization problems. The problems are used by Convex itself to test and benchmark its code, but can also be used by solvers to test and benchmark their code.</p><p>ProblemDepot has two main methods for accessing these problems: <code>Convex.ProblemDepot.run_tests</code> and <code>Convex.ProblemDepot.benchmark_suite</code>.</p><p>For example, to test the solver SCS on all the problems of the depot except the mixed-integer problems (which it cannot handle), run</p><pre><code class="language-julia">using Convex, SCS, Test
@testset "SCS" begin
    Convex.ProblemDepot.run_tests(; exclude=[r"mip"]) do p
        solve!(p, SCSSolver(verbose=0, eps=1e-6))
    end
end</code></pre><h2><a class="nav-anchor" href="#How-to-write-a-ProblemDepot-problem-1" id="How-to-write-a-ProblemDepot-problem-1">How to write a ProblemDepot problem</a></h2><p>The problems are organized into folders in <code>src/problem_depot/problems</code>. Each is written as a function, annotated by <code>@add_problem</code>, and a name, which is used to group the problems. For example, here is a simple problem:</p><pre><code class="language-julia">@add_problem affine function affine_negate_atom(handle_problem!, ::Val{test}, atol, rtol, ::Type{T}) where {T, test}
    x = Variable()
    p = minimize(-x, [x &lt;= 0])
    if test
        @test vexity(p) == AffineVexity()
    end
    handle_problem!(p)
    if test
        @test p.optval ≈ 0 atol=atol rtol=rtol
        @test evaluate(-x) ≈ 0 atol=atol rtol=rtol
    end
end</code></pre><p>The <code>@add_problem</code> call adds the problem to the registry of problems in <a href="#Convex.ProblemDepot.PROBLEMS"><code>Convex.ProblemDepot.PROBLEMS</code></a>, which in turn is used by <a href="#Convex.ProblemDepot.run_tests"><code>Convex.ProblemDepot.run_tests</code></a> and <a href="#Convex.ProblemDepot.benchmark_suite"><code>Convex.ProblemDepot.benchmark_suite</code></a>. Next, <code>affine</code> is the grouping of the problem; this problem came from one of the affine tests, and in particular is testing the negation atom. Next is the function signature:</p><pre><code class="language-julia">function affine_negate_atom(handle_problem!, ::Val{test}, atol, rtol, ::Type{T}) where {T, test}</code></pre><p>this should be the same for every problem, except for the name, which is a description of the problem. It should include what kind of atoms it uses (<code>affine</code> in this case), so that certain kinds of atoms can be ruled out by the <code>exclude</code> keyword to <a href="#Convex.ProblemDepot.run_tests"><code>Convex.ProblemDepot.run_tests</code></a> and <a href="#Convex.ProblemDepot.benchmark_suite"><code>Convex.ProblemDepot.benchmark_suite</code></a>; for example, many solvers cannot solve mixed-integer problems, so <code>mip</code> is included in the name of such problems.</p><p>Then begins the body of the problem. It is setup like any other Convex.jl problem, only <code>handle_problem!</code> is called instead of <code>solve!</code>. This allows particular solvers to be used (via e.g. choosing <code>handle_problem! = p -&gt; solve!(p, solver)</code>), or for any other function of the problem (e.g. <code>handle_problem! = p -&gt; Convex.conic_problem(p)</code> which is used for benchmarking problem formulation speed.) Tests should be included and gated behind <code>if test</code> blocks, so that tests can be skipped for benchmarking, or in the case that the problem is not in fact solved during <code>handle_problem!</code>.</p><p>The fact that the problems may not be solved during <code>handle_problem!</code> brings with it a small complication: any command that assumes the problem has been solved should be behind an <code>if test</code> check. For example, in some of the problems, <code>real(x.value)</code> is used, for a variable <code>x</code>; perhaps as</p><pre><code class="language-julia">x_re = real(x.value)
if test
    @test x_re = ...
end</code></pre><p>However, if the problem <code>x</code> is used in has not been solved, then <code>x.value === nothing</code>, and <code>real(nothing)</code> throws an error. So instead, this should be rewritten as</p><pre><code class="language-julia">if test
    x_re = real(x.value)
    @test x_re = ...
end</code></pre><h2><a class="nav-anchor" href="#Benchmark-only-problems-1" id="Benchmark-only-problems-1">Benchmark-only problems</a></h2><p>To add problems for benchmarking without tests, place problems in <code>src/problem_depot/problems/benchmark</code>, and include <code>benchmark</code> in the name. These problems will be automatically skipped during <code>run_tests</code> calls. For example, to benchmark the time it takes to add an SDP constraint, we have the problem</p><pre><code class="language-julia">@add_problem constraints_benchmark function sdp_constraint(handle_problem!, args...)
    p = satisfy()
    x = Variable(44, 44) # 990 vectorized entries
    push!(p.constraints, x ⪰ 0)
    handle_problem!(p)
    nothing
end</code></pre><p>However, this "problem" has no tests or interesting content for testing, so we skip it during testing. Note, we use <code>args...</code> in the function signature so that it may be called with the standard function signature</p><pre><code class="language-julia">f(handle_problem!, ::Val{test}, atol, rtol, ::Type{T}) where {T, test}</code></pre><h2><a class="nav-anchor" href="#Reference-1" id="Reference-1">Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Convex.ProblemDepot.run_tests" id="Convex.ProblemDepot.run_tests"><code>Convex.ProblemDepot.run_tests</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">run_tests(
    handle_problem!::Function;
    problems::Union{Nothing, Vector{String}, Vector{Regex}} = nothing; 
    exclude::Vector{Regex} = Regex[],
    T=Float64, atol=1e-3, rtol=0.0, 
)</code></pre><p>Run a set of tests. <code>handle_problem!</code> should be a function that takes one argument, a Convex.jl <code>Problem</code> and processes it (e.g. <code>solve!</code> the problem with a specific solver).</p><p>Use <code>exclude</code> to exclude a subset of sets; automatically excludes <code>r"benchmark"</code>. Optionally, pass a second argument <code>problems</code> to only allow certain problems (specified by exact names or regex). The test tolerances specified by <code>atol</code> and <code>rtol</code>. Set <code>T</code> to choose a numeric type for the problem. Currently this is only used for choosing the type parameter of the underlying MathOptInterface model, but not for the actual problem data.</p><p><strong>Examples</strong></p><pre><code class="language-julia">run_tests(exclude=[r"mip"]) do p
    solve!(p, SCSSolver(verbose=0))
end</code></pre></div></div><a class="source-link" href="https://github.com/JuliaOpt/Convex.jl/blob/aa61f5342842a70670a37ebb91d4c646e058294d/src/problem_depot/problem_depot.jl#LL83-L109" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Convex.ProblemDepot.benchmark_suite" id="Convex.ProblemDepot.benchmark_suite"><code>Convex.ProblemDepot.benchmark_suite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">benchmark_suite(
    handle_problem!::Function,
    problems::Union{Nothing, Vector{String}, Vector{Regex}} = nothing; 
    exclude::Vector{Regex} = Regex[],
    test = Val(false),
    T=Float64, atol=1e-3, rtol=0.0, 
)</code></pre><p>Create a benchmark<em>suite of benchmarks. `handle</em>problem!<code>should be a function that takes one argument, a Convex.jl</code>Problem<code>and processes it (e.g.</code>solve!<code>the problem with a specific solver). Pass a second argument</code>problems` to specify run benchmarks only with certain problems (specified by exact names or regex).</p><p>Use <code>exclude</code> to exclude a subset of benchmarks. Optionally, pass a second argument <code>problems</code> to only allow certain problems (specified by exact names or regex). Set <code>test=true</code> to also check the answers, with tolerances specified by <code>atol</code> and <code>rtol</code>. Set <code>T</code> to choose a numeric type for the problem. Currently this is only used for choosing the type parameter of the underlying MathOptInterface model, but not for the actual problem data.</p><p><strong>Examples</strong></p><pre><code class="language-julia">benchmark_suite(exclude=[r"mip"]) do p
    solve!(p, SCSSolver(verbose=0))
end</code></pre></div></div><a class="source-link" href="https://github.com/JuliaOpt/Convex.jl/blob/aa61f5342842a70670a37ebb91d4c646e058294d/src/problem_depot/problem_depot.jl#LL127-L155" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Convex.ProblemDepot.foreach_problem" id="Convex.ProblemDepot.foreach_problem"><code>Convex.ProblemDepot.foreach_problem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">foreach_problem(apply::Function, [class::String],
    problems::Union{Nothing, Vector{String}, Vector{Regex}} = nothing; 
    exclude::Vector{Regex} = Regex[])</code></pre><p>Provides a convience method for iterating over problems in <a href="#Convex.ProblemDepot.PROBLEMS"><code>PROBLEMS</code></a>.  For each problem in <a href="#Convex.ProblemDepot.PROBLEMS"><code>PROBLEMS</code></a>, apply the function <code>apply</code>, which takes two arguments: the name of the function associated to the problem, and the function associated to the problem itself.</p><p>Optionally, pass a second argument <code>class</code> to only iterate over a class of problems (<code>class</code> should satsify <code>class ∈ keys(PROBLEMS)</code>), and pass third argument <code>problems</code> to only allow certain problems (specified by exact names or regex). Use the <code>exclude</code> keyword argument to exclude problems by regex.</p></div></div><a class="source-link" href="https://github.com/JuliaOpt/Convex.jl/blob/aa61f5342842a70670a37ebb91d4c646e058294d/src/problem_depot/problem_depot.jl#LL44-L58" target="_blank">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Convex.ProblemDepot.PROBLEMS" id="Convex.ProblemDepot.PROBLEMS"><code>Convex.ProblemDepot.PROBLEMS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const PROBLEMS = Dict{String, Dict{String, Function}}()</code></pre><p>A "depot" of Convex.jl problems, subdivided into categories. Each problem is stored as a function with the signature</p><pre><code class="language-none">f(handle_problem!, ::Val{test}, atol, rtol, ::Type{T}) where {T, test}</code></pre><p>where <code>handle_problem!</code> specifies what to do with the <code>Problem</code> instance (e.g., <code>solve!</code> it with a chosen solver), an option <code>test</code> to choose whether or not to test the values (assuming it has been solved), tolerances for the tests, and a numeric type in which the problem should be specified (currently, this is not respected and all problems are specified in <code>Float64</code> precision).</p><p>See also <a href="#Convex.ProblemDepot.run_tests"><code>run_tests</code></a> and <a href="#Convex.ProblemDepot.benchmark_suite"><code>benchmark_suite</code></a> for helpers to use these problems in testing or benchmarking.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; PROBLEMS["affine"]["affine_diag_atom"]
affine_diag_atom (generic function with 1 method)</code></pre></div></div><a class="source-link" href="https://github.com/JuliaOpt/Convex.jl/blob/aa61f5342842a70670a37ebb91d4c646e058294d/src/problem_depot/problem_depot.jl#LL17-L41" target="_blank">source</a></section><footer><hr/><a class="previous" href="../advanced/"><span class="direction">Previous</span><span class="title">Advanced</span></a><a class="next" href="../contributing/"><span class="direction">Next</span><span class="title">Contributing</span></a></footer></article></body></HTML>